const getMean = (array) => array.reduce((acc, el) => acc + el, 0) / array.length;

const getMedian = (array) => {
    const sorted = array.toSorted((a, b) => a - b);
    const median =
        sorted.length % 2 === 0
            ? getMean([sorted[sorted.length / 2], sorted[sorted.length / 2 - 1]])
            : sorted[Math.floor(sorted.length / 2)];
    return median;
}

const getMode = (array) => {
    const counts = {};
    array.forEach(el => counts[el] = counts[el] ? counts[el] + 1 : 1);

    if (new Set(Object.values(counts)).size === 1) {
        return null;
    }
    const highest = Object.keys(counts).sort(
        (a, b) => counts[b] - counts[a]
    )[0];
    const mode = Object.keys(counts).filter(
        (el) => counts[el] === counts[highest]
    );
    return mode.join(", ");
}

const calculate = () => {
    const value = document.querySelector("#numbers").value;
    const array = value.split(/,\s*/g);
    const numbers = array.map(el => Number(el)).filter(el => !isNaN(el));

    const mean = getMean(numbers);
    const median = getMedian(numbers);

    document.querySelector("#mean").textContent = mean;
    document.querySelector("#median").textContent = median;
};




























/*
Шаг 1

Статистика — это способ использования математики для осмысления данных. Она помогает нам понимать закономерности и тенденции в информации, чтобы мы могли делать прогнозы и принимать решения на основе этой информации. В этом задании вы создадите статистический калькулятор, который принимает набор чисел и возвращает среднее арифметическое, медиану, моду, стандартное отклонение и дисперсию. HTML и CSS предоставлены. Не стесняйтесь изучать код — вы можете заметить, что функция calculate вызывается при отправке формы. Когда будете готовы, объявите переменную calculate и присвойте ей пустую функцию в файле script.js.





Шаг 2

Для начала функции calculate необходимо найти число, введенное в поле ввода #numbers. Для этого используйте .querySelector, чтобы найти поле ввода, а затем используйте свойство .value, чтобы получить введенное число. Сохраните это значение в переменной value.


const value = document.querySelector("#numbers").value;




Шаг 3

Теперь, когда у вас есть значение входных данных, вам нужно разбить его на массив чисел. Для этого используйте метод `.split()`. Метод `.split()` принимает строку и разбивает её на массив строк. Вы можете передать ему строку символов или регулярное выражение для использования в качестве разделителя. Например, `string.split(",")` разделит строку по каждой запятой и вернет массив строк. Используйте регулярное выражение /,\s*'/'g;
для разделения строки значений по запятым. Вы можете настроить его в зависимости от количества пробелов, разделяющих ваши значения. Сохраните массив в переменной типа массив.


const array = value.split(/,\s*'/'g);




Шаг 4

Значение элемента ввода всегда является строкой, даже если тип ввода — число. Вам необходимо преобразовать этот массив строк в массив чисел. Для этого можно использовать метод `.map()`. Создайте переменную типа `numbers` и присвойте ей значение метода `array.map()`. Помните, что метод `.map()` создает новый массив, а не изменяет исходный массив.


const numbers = array.map();




Шаг 5

Метод `.map()` принимает в качестве первого аргумента функцию обратного вызова. Эта функция обратного вызова принимает несколько аргументов, но первым из них является текущий обрабатываемый элемент. Вот пример:
Пример кода

array.map(el => {

 })

 Функция обратного вызова должна возвращать значение. В данном случае вам нужно вернуть значение каждого элемента, преобразованное в число. Это можно сделать, используя конструктор `Number()`, передав элемент в качестве аргумента. Добавьте в метод `.map()` функцию обратного вызова, которая преобразует каждый элемент в число.


const numbers = array.map(el => Number(el));




Шаг 6

Пользователь может ввести в поле ввода любой текст. Важно убедиться, что вы работаете только с числами. Конструктор Number() вернет NaN (что означает «не число»), если переданное значение не может быть преобразовано в число. Вам необходимо отфильтровать эти значения — к счастью, для этого есть специальный метод для массивов. Метод `.filter()` позволяет отфильтровывать элементы из массива, создавая при этом новый массив. Объявите переменную filtered и присвойте ей значение `numbers.filter()`.


const filtered = numbers.filter();




Шаг 7

Подобно методу `.map()`, метод `.filter()` принимает функцию обратного вызова. Функция обратного вызова принимает текущий элемент в качестве первого аргумента.
Пример кода

`array.filter(el => { })` Функция обратного вызова должна возвращать логическое значение, указывающее, следует ли включать элемент в новый массив. В данном случае вы хотите вернуть `true`, если элемент не является NaN (не числом). Однако здесь нельзя проверить равенство, поскольку NaN не равно самому себе. Вместо этого вы можете использовать метод `isNaN()`, который возвращает `true`, если аргумент равен NaN. Добавьте функцию обратного вызова в ваш метод `.filter()` с `el` в качестве параметра и используйте неявное возвращаемое значение, чтобы вернуть `true`, если элемент НЕ является NaN.


const filtered = numbers.filter(el => !isNaN(el));




Шаг 8

Методы массивов часто можно объединять в цепочку для выполнения нескольких операций одновременно. Например:
Пример кода

array.map().filter();

Метод .map() вызывается для массива, а затем метод .filter() вызывается для результата метода .map(). Это называется цепочкой методов. Следуя этому примеру, удалите переменную filtered и объедините вызов .filter() с вызовом .map() выше. Не удаляйте ни одну из функций обратного вызова.


const numbers = array.map(el => Number(el)).filter(el => !isNaN(el));




Шаг 9

На этом пока что функция calculate завершается. Пришло время написать логику вычисления среднего значения. Создайте пустую функцию с именем getMean. Она должна принимать один параметр — array.


const getMean = (array) => {

};




Шаг 10

Среднее арифметическое — это среднее значение всех чисел в списке. Первый шаг в вычислении среднего арифметического — это суммирование всех чисел в списке. У массивов есть ещё один метод, называемый `.reduce()`, который идеально подходит для этой ситуации. Метод `.reduce()` принимает массив и применяет функцию обратного вызова для сжатия массива в одно значение. Объявите переменную `sum` и присвойте ей значение `array.reduce()`.


const sum = array.reduce();




Шаг 11

Как и другие методы, метод `.reduce()` принимает функцию обратного вызова. Однако эта функция обратного вызова принимает как минимум два параметра. Первый — это аккумулятор, а второй — текущий элемент массива. Возвращаемое значение функции обратного вызова становится значением аккумулятора на следующей итерации.
Пример кода

array.reduce((acc, el) => {

 });

 Для вашей переменной суммы передайте функцию обратного вызова методу `.reduce()`, которая принимает в качестве параметров аккумулятор и текущий элемент. Функция обратного вызова должна возвращать сумму аккумулятора и текущего элемента.


const sum = array.reduce((acc, el) => acc + el);




Шаг 12

Метод `.reduce()` принимает второй аргумент, который используется в качестве начального значения аккумулятора. Без второго аргумента метод `.reduce()` использует первый элемент массива в качестве аккумулятора, что может привести к неожиданным результатам. Для большей безопасности лучше установить начальное значение. Вот пример установки начального значения в пустую строку:
Пример кода

array.reduce((acc, el) => acc + el.toLowerCase(), "");

Установите начальное значение аккумулятора равным 0.


const sum = array.reduce((acc, el) => acc + el, 0);




Шаг 13

Следующий шаг в вычислении среднего значения — разделить сумму чисел на количество чисел в списке. Объявите переменную `mean` и присвойте ей значение суммы, деленной на длину массива.


const mean = sum / array.length;




Шаг 14

Наконец, вам нужно вернуть значение среднего.




Шаг 15

На самом деле, эту логику можно немного упростить. Используя неявный возврат стрелочной функции, вы можете напрямую вернуть значение метода `.reduce()`, деленное на длину массива, без необходимости присваивать какие-либо переменные. Обновите функцию `getMean`, как описано выше.


const getMean = (array) => array.reduce((acc, el) => acc + el, 0) / array.length;




Шаг 16

Теперь вам нужно использовать вашу новую функцию getMean. В вашей функции calculate объявите переменную mean и присвойте ей значение из функции getMean(numbers).


const mean = getMean(numbers);




Шаг 17 Чтобы отобразить значение переменной mean, в вашем приложении уже есть готовый элемент #mean. Используйте .querySelector, чтобы найти этот элемент, а затем установите для его .textContent значение переменной mean.


document.querySelector("#mean").textContent = mean;




Шаг 18

Если вы протестируете свою форму со списком чисел, вы должны увидеть среднее значение на странице. Однако это работает только потому, что iframe freeCodeCamp имеет специальные настройки. Обычно, когда форма отправляется, событие запускает обновление страницы. Чтобы решить эту проблему, добавьте return false; после вызова calculate(); в атрибуте onsubmit.
(HTML str 14)


<form onsubmit="calculate(); return false;">




Шаг 19

Пора приступить к вычислению медианы. Медиана — это середина набора чисел. Начните с пустой функции с именем getMedian, которая должна принимать в качестве параметра массив.


const getMedian = (array) => {

};




Шаг 20

Первый шаг в вычислении медианы — убедиться, что список чисел отсортирован от наименьшего к наибольшему. Для этого идеально подходит метод массива — метод .sort(). Объявите sorted переменную и присвойте ей значение, полученное с помощью метода array.sort().


const sorted = array.sort();




Шаг 21

По умолчанию метод .sort() преобразует элементы массива в строки, а затем сортирует их в алфавитном порядке. Метод .sort() изменяет исходный массив. Это хорошо работает со строками, но не так хорошо с числами. Например, 10 идет перед 2 при сортировке как строк, но 2 идет перед 10 при сортировке как чисел. Чтобы исправить это, вы можете передать функцию обратного вызова методу .sort(). Эта функция принимает два аргумента, которые представляют два сравниваемых элемента. Функция должна возвращать значение меньше 0, если первый элемент должен идти перед вторым, значение больше 0, если первый элемент должен идти после второго, и 0, если два элемента должны оставаться на своих текущих позициях. Чтобы отсортировать числа от наименьшего к наибольшему, передайте функцию обратного вызова, которая принимает параметры a и b и возвращает результат вычитания b из a.


const sorted = array.sort((a, b) => a - b);




Шаг 22

На следующих нескольких шагах вы узнаете, как определить, является ли длина массива четной или нечетной, а также как найти медиану. Затем вы сможете применить полученные знания к функции getMedian. Чтобы проверить, является ли число четным или нечетным, можно использовать оператор деления по модулю %. Оператор деления по модулю возвращает остаток от деления двух чисел. Вот пример проверки четности или нечетности длины массива:
Пример кода

// проверка четности длины массива
arr.length % 2 === 0;

// проверка нечетности длины массива
arr.length % 2 === 1;

Если остаток равен 0, число четное. Если остаток равен 1, число нечетное. Создайте переменную с именем isEven. Затем используйте оператор деления по модулю, чтобы проверить, является ли длина массива testArr2 четной. Присвойте это выражение переменной isEven. Ниже переменной isEven выведите значение переменной isEven в консоль. Откройте консоль, чтобы увидеть результат.


const testArr1 = [1, 2, 3, 4, 5];
const testArr2 = [1, 2, 3, 4, 5, 6];
const isEven = testArr2.length % 2 === 0;
console.log(isEven);




Шаг 23

Чтобы найти медиану массива с нечетным числом элементов, вам нужно найти и вернуть среднее число. Вот как найти среднее число массива с нечетным числом элементов:
Пример кода

arr[Math.floor(arr.length / 2)];

Вот более длинный пример нахождения среднего числа массива с 5 элементами:
Пример кода

const numbers = [1, 2, 3, 4, 5];
const middleNumber = numbers[Math.floor(numbers.length / 2)];
console.log(middleNumber); // 3

Причина использования Math.floor заключается в том, что результат деления нечетного числа на 2 будет десятичным числом. Math.floor округлит до ближайшего целого числа в меньшую сторону. Объявите переменную oddListMedian и присвойте ей результат нахождения среднего числа массива testArr1. Затем выведите значение переменной oddListMedian в консоль. Откройте консоль, чтобы увидеть результат.


const testArr1 = [1, 2, 3, 4, 5];
const oddListMedian = testArr1[Math.floor(testArr1.length / 2)];
console.log(oddListMedian);




Шаг 24

Чтобы найти медиану четного списка чисел, необходимо найти два средних числа и вычислить их среднее арифметическое. Вот как найти два средних числа четного списка элементов:
Пример кода

// первое среднее число
arr[arr.length / 2];
// второе среднее число
arr[(arr.length / 2) - 1];

Чтобы найти медиану, можно использовать функцию getMean, которая складывает средние числа и делит сумму на 2.
Пример кода

const numbers = [1, 2, 3, 4];
const firstMiddleNumber = numbers[numbers.length / 2];
const secondMiddleNumber = numbers[(numbers.length / 2) - 1];
// результат 2.5
getMean([firstMiddleNumber, secondMiddleNumber]);

Создайте переменную evenListMedian и присвойте ей результат нахождения медианы объекта testArr2. Затем выведите значение переменной evenListMedian в консоль.


const evenListMedian = getMean(testArr2);
console.log(evenListMedian);




25

const testArr1 = [1, 2, 3, 4, 5];
const testArr2 = [1, 2, 3, 4, 5, 6];
const isEven = testArr2.length % 2 === 0;
console.log(isEven);
const oddListMedian = testArr1[Math.floor(testArr1.length / 2)];
console.log(oddListMedian);
const evenListMedian = getMean([testArr2[testArr2.length / 2 - 1], testArr2[testArr2.length / 2]]);
console.log(evenListMedian);




Шаг 26

Метод `.sort()` изменяет исходный массив — другими словами, он напрямую меняет порядок элементов. Это обычно считается плохой практикой, поскольку может привести к неожиданным побочным эффектам. Вместо этого следует использовать метод `.toSorted()`, который создает новый массив. Измените вызов `.sort()` на `.toSorted()`. Не изменяйте функцию обратного вызова.


const sorted = array.toSorted((a, b) => a - b);




Шаг 27

Теперь пришло время применить полученные знания к функции getMedian. Внутри функции getMedian проверьте, является ли длина массива sorted четной. Если да, найдите два средних числа, вычислите их среднее значение и верните результат. Если длина массива sorted нечетная, верните среднее число. Обязательно работайте с массивом sorted, чтобы найти средние числа. Также, если вам нужна помощь, вернитесь к предыдущим шагам, чтобы узнать, как найти медиану для массива.


const getMedian = (array) => {
  const sorted = array.toSorted((a, b) => a - b);
  if (sorted.length % 2 === 0) {
    return getMean([sorted[sorted.length / 2 - 1], sorted[sorted.length / 2]]);
  } else {
    return sorted[Math.floor(sorted.length / 2)];
  }
}

***

const getMedian = (array) => {
  const sorted = array.toSorted((a, b) => a - b);
  const median =
    sorted.length % 2 === 0
      ? getMean([sorted[sorted.length / 2], sorted[sorted.length / 2 - 1]])
      : sorted[Math.floor(sorted.length / 2)];
  return median;
}




Шаг 28

Как и в случае с функцией getMean, вам необходимо добавить функцию getMedian в логику вычислений. Объявите переменную median и присвойте ей значение getMedian(numbers). Затем запросите DOM для элемента #median и установите textContent равным median.


const median = getMedian(numbers);


document.querySelector("#median").textContent = median;




Шаг 29

Следующий шаг — вычисление моды, то есть числа, которое встречается в списке чаще всего. Для начала объявите функцию getMode, которая принимает тот же параметр в виде array, что и раньше.


const getMode = (array) => {

};




Шаг 30

Для вычисления количества вхождений можно использовать следующий подход:
Пример кода

const numbersArr = [1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4];
const counts = {};
numbersArr.forEach((el) => {
  if (counts[el]) {
    counts[el] += 1;
  } else {
    counts[el] = 1;
  }
});

 Проверьте, есть ли текущее число уже в объекте counts. Если есть, увеличьте его на 1. Если нет, установите его равным 1. Результирующий объект. Ключами являются числа из массива, а значениями — количество раз, которое каждое число встречается в списке:
 Пример кода

 { 1: 3, 2: 3, 3: 3, 4: 3, 5: 2 }

 Для этого шага начните с объявления пустого объекта counts. Позже в проекте вы будете использовать этот объект для вычисления моды списка чисел.


const counts = {};




Шаг 31

Чтобы лучше понять, как будет работать функция getMode, вам нужно будет вывести её содержимое. Это позволит вам увидеть, что происходит по мере построения функции. Но сначала вам нужно вернуть array, чтобы его можно было правильно протестировать. Внутри вашей функции getMode верните ваш параметр-array.

return array;




Шаг 32

Внутри функции calculate вы уже вызвали функции getMean и getMedian. Ниже этих вызовов функций добавьте console.log(getMode(numbers)). Чтобы увидеть результат, введите числа 4, 4, 2, 5 и нажмите кнопку «Вычислить». Откройте консоль, чтобы увидеть следующий массив:
Пример кода

[ 4, 4, 2, 5 ]


console.log(getMode(numbers));




Шаг 33

Внутри вашей функции getMode, на пустой строке над оператором return, вызовите метод forEach для array. Ваш метод .forEach() должен содержать пустую функцию обратного вызова, которая принимает параметр el. В следующих нескольких шагах вы будете использовать этот цикл для подсчета частоты вхождений каждого числа в массиве.


array.forEach((el) => {});




Шаг 34

Внутри функции обратного вызова array.forEach() проверьте, находится ли текущий элемент внутри объекта counts. Если элемент найден, увеличьте значение counts[el] на 1. В противном случае присвойте counts[el] число 1. Измените оператор return так, чтобы он возвращал counts вместо array. Для проверки введите числа 4, 4, 2, 5 и нажмите «Вычислить». В консоли должно отобразиться следующее:
Пример кода

{ '2': 1, '4': 2, '5': 1 }




const getMode = (array) => {
  const counts = {};
  array.forEach(el => {
    if (counts[el]) {
      counts[el] += 1;
    } else {
      counts[el] = 1;
    }
  })
  return counts;
}




Шаг 35

Есть еще один способ написать цикл forEach. Вместо использования блока body () => {} для функции обратного вызова, можно использовать тело выражения () =>. Вам придется преобразовать операторы if...else в выражение. Напишите выражение в виде тернарного оператора и используйте одно присваивание для тернарного оператора. Пример кода assignment = condition ? exprIfTrue : exprIfFalse Преобразуйте функцию обратного вызова forEach, чтобы использовать тело выражения, и замените операторы тернарным оператором.


const getMode = (array) => {
  const counts = {};
  array.forEach(el => counts[el] = counts[el] ? counts[el] + 1 : 1);
  return counts;
}




Шаг 36

Теперь, когда вы лучше понимаете, как работает функция getMode, вы можете удалить оператор console.log(getMode(numbers)) из функции calculate.




Шаг 37

Возвращение переменной counts было необходимо только для тестирования. Теперь, когда тестирование завершено, удалите строку return counts из функции getMode.




Шаг 38

При вычислении моды набора данных необходимо учитывать несколько крайних случаев. Во-первых, если каждое значение встречается одинаковое количество раз, моды нет. Для вычисления моды используется множество (Set). Множество — это структура данных, которая допускает только уникальные значения. Если вы передадите массив в конструктор множества, он удалит все повторяющиеся значения. Начните с создания оператора if. В условии создайте множество с помощью newSet() и передайте ему Object.values() вашего объекта counts. Если свойство size этого множества равно 1, это означает, что каждое значение встречается одинаковое количество раз. В этом случае верните null из вашей функции.


  if (new Set(Object.values(counts)).size === 1) {
    return null;
  };





Шаг 39

Теперь вам нужно найти значение, которое встречается с наибольшей частотой. Для этого вы будете использовать метод Object.keys(). Начните с объявления переменной `highest` и присвойте ей значение из метода Object.keys() объекта `counts`.


const highest = Object.keys(counts);




Шаг 40

Теперь вам нужно правильно отсортировать значения. Привяжите метод `.sort()` к вызову `Object.keys()`. Для функции обратного вызова вам потребуется использовать объект `counts` для сравнения значений каждого ключа. Вы можете использовать параметры `a` и `b` для доступа к ключам. Затем верните значение `counts[b]` минус значение `counts[a]`. Наконец, получите доступ к первому элементу массива, используя скобки, чтобы завершить создание highest переменной.


const highest = Object.keys(counts).sort((a, b) => counts[b] - counts[a])[0];




Шаг 41

Если несколько чисел в ряду встречаются с одинаковой максимальной частотой, все они считаются модой. В противном случае модой является число, которое встречается чаще всего, то есть это единственное число является модой. К счастью, вы можете обработать оба этих случая одновременно с помощью метода `.filter()`. Начните с объявления переменной `mode` и присвойте ей значение `Object.keys(counts)`.


const mode = Object.keys(counts);




Шаг 42

Теперь добавьте метод filter к вашему последнему вызову Object.keys(). Функция обратного вызова должна возвращать значение, равное ли значение counts[el] значению counts[highest].


const mode = Object.keys(counts).filter((el) => counts[el] === counts[highest]);




Шаг 43

Пришло время вернуть переменную `mode`. `mode` — это массив, поэтому верните его в виде строки с помощью метода `.join()`. Разделите элементы запятой, за которой следует пробел.


return mode.join(", ");











*/