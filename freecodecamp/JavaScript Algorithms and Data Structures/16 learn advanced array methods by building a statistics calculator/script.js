const getMean = (array) => {
    const sum = array.reduce((acc, el) => acc + el, 0);
    const mean = sum / array.length;
};

const calculate = () => {
    const value = document.querySelector("#numbers").value;
    const array = value.split(/,\s*/g);
    const numbers = array.map(el => Number(el)).filter(el => !isNaN(el));
};




























/*
Шаг 1

Статистика — это способ использования математики для осмысления данных. Она помогает нам понимать закономерности и тенденции в информации, чтобы мы могли делать прогнозы и принимать решения на основе этой информации. В этом задании вы создадите статистический калькулятор, который принимает набор чисел и возвращает среднее арифметическое, медиану, моду, стандартное отклонение и дисперсию. HTML и CSS предоставлены. Не стесняйтесь изучать код — вы можете заметить, что функция calculate вызывается при отправке формы. Когда будете готовы, объявите переменную calculate и присвойте ей пустую функцию в файле script.js.





Шаг 2

Для начала функции calculate необходимо найти число, введенное в поле ввода #numbers. Для этого используйте .querySelector, чтобы найти поле ввода, а затем используйте свойство .value, чтобы получить введенное число. Сохраните это значение в переменной value.


const value = document.querySelector("#numbers").value;




Шаг 3

Теперь, когда у вас есть значение входных данных, вам нужно разбить его на массив чисел. Для этого используйте метод `.split()`. Метод `.split()` принимает строку и разбивает её на массив строк. Вы можете передать ему строку символов или регулярное выражение для использования в качестве разделителя. Например, `string.split(",")` разделит строку по каждой запятой и вернет массив строк. Используйте регулярное выражение /,\s*'/'g;
для разделения строки значений по запятым. Вы можете настроить его в зависимости от количества пробелов, разделяющих ваши значения. Сохраните массив в переменной типа массив.


const array = value.split(/,\s*'/'g);




Шаг 4

Значение элемента ввода всегда является строкой, даже если тип ввода — число. Вам необходимо преобразовать этот массив строк в массив чисел. Для этого можно использовать метод `.map()`. Создайте переменную типа `numbers` и присвойте ей значение метода `array.map()`. Помните, что метод `.map()` создает новый массив, а не изменяет исходный массив.


const numbers = array.map();




Шаг 5

Метод `.map()` принимает в качестве первого аргумента функцию обратного вызова. Эта функция обратного вызова принимает несколько аргументов, но первым из них является текущий обрабатываемый элемент. Вот пример:
Пример кода

array.map(el => {

 })

 Функция обратного вызова должна возвращать значение. В данном случае вам нужно вернуть значение каждого элемента, преобразованное в число. Это можно сделать, используя конструктор `Number()`, передав элемент в качестве аргумента. Добавьте в метод `.map()` функцию обратного вызова, которая преобразует каждый элемент в число.


const numbers = array.map(el => Number(el));




Шаг 6

Пользователь может ввести в поле ввода любой текст. Важно убедиться, что вы работаете только с числами. Конструктор Number() вернет NaN (что означает «не число»), если переданное значение не может быть преобразовано в число. Вам необходимо отфильтровать эти значения — к счастью, для этого есть специальный метод для массивов. Метод `.filter()` позволяет отфильтровывать элементы из массива, создавая при этом новый массив. Объявите переменную filtered и присвойте ей значение `numbers.filter()`.


const filtered = numbers.filter();




Шаг 7

Подобно методу `.map()`, метод `.filter()` принимает функцию обратного вызова. Функция обратного вызова принимает текущий элемент в качестве первого аргумента.
Пример кода

`array.filter(el => { })` Функция обратного вызова должна возвращать логическое значение, указывающее, следует ли включать элемент в новый массив. В данном случае вы хотите вернуть `true`, если элемент не является NaN (не числом). Однако здесь нельзя проверить равенство, поскольку NaN не равно самому себе. Вместо этого вы можете использовать метод `isNaN()`, который возвращает `true`, если аргумент равен NaN. Добавьте функцию обратного вызова в ваш метод `.filter()` с `el` в качестве параметра и используйте неявное возвращаемое значение, чтобы вернуть `true`, если элемент НЕ является NaN.


const filtered = numbers.filter(el => !isNaN(el));




Шаг 8

Методы массивов часто можно объединять в цепочку для выполнения нескольких операций одновременно. Например:
Пример кода

array.map().filter();

Метод .map() вызывается для массива, а затем метод .filter() вызывается для результата метода .map(). Это называется цепочкой методов. Следуя этому примеру, удалите переменную filtered и объедините вызов .filter() с вызовом .map() выше. Не удаляйте ни одну из функций обратного вызова.


const numbers = array.map(el => Number(el)).filter(el => !isNaN(el));




Шаг 9

На этом пока что функция calculate завершается. Пришло время написать логику вычисления среднего значения. Создайте пустую функцию с именем getMean. Она должна принимать один параметр — array.


const getMean = (array) => {

};




Шаг 10

Среднее арифметическое — это среднее значение всех чисел в списке. Первый шаг в вычислении среднего арифметического — это суммирование всех чисел в списке. У массивов есть ещё один метод, называемый `.reduce()`, который идеально подходит для этой ситуации. Метод `.reduce()` принимает массив и применяет функцию обратного вызова для сжатия массива в одно значение. Объявите переменную `sum` и присвойте ей значение `array.reduce()`.


const sum = array.reduce();




Шаг 11

Как и другие методы, метод `.reduce()` принимает функцию обратного вызова. Однако эта функция обратного вызова принимает как минимум два параметра. Первый — это аккумулятор, а второй — текущий элемент массива. Возвращаемое значение функции обратного вызова становится значением аккумулятора на следующей итерации.
Пример кода

array.reduce((acc, el) => {

 });

 Для вашей переменной суммы передайте функцию обратного вызова методу `.reduce()`, которая принимает в качестве параметров аккумулятор и текущий элемент. Функция обратного вызова должна возвращать сумму аккумулятора и текущего элемента.


const sum = array.reduce((acc, el) => acc + el);




Шаг 12

Метод `.reduce()` принимает второй аргумент, который используется в качестве начального значения аккумулятора. Без второго аргумента метод `.reduce()` использует первый элемент массива в качестве аккумулятора, что может привести к неожиданным результатам. Для большей безопасности лучше установить начальное значение. Вот пример установки начального значения в пустую строку:
Пример кода

array.reduce((acc, el) => acc + el.toLowerCase(), "");

Установите начальное значение аккумулятора равным 0.


const sum = array.reduce((acc, el) => acc + el, 0);




Шаг 13

Следующий шаг в вычислении среднего значения — разделить сумму чисел на количество чисел в списке. Объявите переменную `mean` и присвойте ей значение суммы, деленной на длину массива.


const mean = sum / array.length;




*/