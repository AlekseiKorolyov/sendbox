const a = () => {
    return "freeCodeCamp " + b();
};

const b = () => {
    return "is " + c();
};

const c = () => {
    return "awesome!";
};

const numberInput = document.getElementById("number-input");
const convertBtn = document.getElementById("convert-btn");
const result = document.getElementById("result");

const decimalToBinary = (input) => {
    let binary = "";

    if (input ===0) {
        binary = "0";
    }

    while (input > 0) {
        binary = (input % 2) + binary;
        input = Math.floor(input / 2);
    }

    result.innerText = binary;
};

const checkUserInput = () => {
    if (
        !numberInput.value ||
        isNaN(parseInt(numberInput.value)) ||
        parseInt(numberInput.value) < 0
    ) {
        alert("Please provide a decimal number greater than or equal to 0");
        return;
    }

    decimalToBinary(parseInt(numberInput.value));
    numberInput.value = "";
};

convertBtn.addEventListener("click", checkUserInput);

numberInput.addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
        checkUserInput();
    }
});




























/*
Шаг 1

В этом проекте вы создадите десятичную и двоичную систему счисления и познакомитесь с обеими системами счисления. Вы также узнаете о рекурсии, используя её для выполнения преобразований. Весь HTML и CSS для этого проекта предоставлены вам. Когда будете готовы начать, используйте метод .getElementById(), чтобы получить элемент ввода с идентификатором "number-input" и сохранить его в переменной numberInput. Используйте тот же метод, чтобы получить элемент кнопки с идентификатором "convert-btn" и сохранить его в переменной convertBtn, а также элемент вывода с идентификатором "result" и сохранить его в переменной result. ПРИМЕЧАНИЕ: В этом проекте будут преобразованы только положительные числа в двоичные.


const numberInput = document.getElementById("number-input");
const convertBtn = document.getElementById("convert-btn");
const result = document.getElementById("result");



Шаг 2

Теперь нужно настроить проверку значения в поле ввода числа при каждом нажатии пользователем кнопки «Преобразовать». Сначала создайте пустую функцию с именем checkUserInput.


const checkUserInput = () => {};




Шаг 3

Хороший способ проверить работоспособность — вывести значение атрибута value элемента numberInput на консоль. Напоминаем, что доступ к значению атрибута value элемента можно получить, используя точку или скобки. В функции checkUserInput используйте console.log() для выведения значения numberInput на консоль.


console.log(numberInput.value);




Шаг 4

Теперь, когда функция checkUserInput() настроена для тестирования, вы можете использовать прослушиватель событий для вызова функции при нажатии кнопки «Конвертировать». Свяжите метод .addEventListener() с convertBtn. Прослушиватель событий должен отслеживать события нажатия и принимать ссылку на функцию checkUserInput в качестве обратного вызова. Помните, что ссылки на функции не вызываются в скобках. После этого при каждом нажатии кнопки «Конвертировать» значение введённого числа должно выводиться в консоль.


convertBtn.addEventListener("click", checkUserInput);




Шаг 5

Кнопка «Преобразовать» теперь должна работать. Но пользователям может быть утомительно вводить число, а затем нажимать эту кнопку каждый раз, когда нужно преобразовать его из десятичного формата в двоичный. Было бы гораздо удобнее выполнять преобразование при нажатии клавиши Enter или Return. Событие keydown срабатывает каждый раз, когда пользователь нажимает клавишу на клавиатуре, и это хороший способ добавить больше интерактивности элементам ввода. Добавьте .addEventListener() к numberInput. Обработчик событий должен отслеживать события keydown и принимать пустую стрелочную функцию в качестве обратного вызова.


numberInput.addEventListener("keydown", () => {});




Шаг 6

Всякий раз, когда прослушиватель событий срабатывает при возникновении события, автоматически создаётся объект события. Этот объект не всегда требуется использовать, как в случае с обработчиком щелчков, описанным выше, но он может быть полезен для доступа к информации о сработавшем событии. Сначала передайте e в качестве параметра функции обратного вызова. Помните, что e — это общее имя параметра для объекта события. Затем выведите e в консоль в теле функции обратного вызова.


numberInput.addEventListener("keydown", (e) => {
  console.log(e);
});




Шаг 7

Если вы откроете консоль браузера и введёте число, вы увидите объекты событий, зарегистрированные в браузере. Если вы внимательно изучите один из этих объектов событий, вы увидите полезные свойства, такие как type и target. Поскольку вы хотите выполнить действие при нажатии клавиши Enter, наиболее полезным свойством будет key, которое возвращает строковое значение нажатой клавиши. Удалите оператор console.log() из функции обратного вызова и добавьте оператор if, который проверяет, равен ли e.key строке «Enter». Тело оператора if пока оставьте пустым. Примечание: поскольку клавиши Enter и Return выполняют схожие функции, они имеют одинаковое строковое значение «Enter».


  if (e.key === "Enter") {

  }




Шаг 8.

Далее, в теле оператора if вызовите функцию checkUserInput(). После этого, если ввести числа в поле ввода и нажать клавишу Enter/Return, вы увидите числа, выведенные на консоль.


checkUserInput();




Шаг 9

Теперь, когда кнопка «Конвертировать» и поле ввода чисел отслеживают нажатия клавиш Enter и клики, пора завершить функцию checkUserInput(). Было бы полезно предупреждать пользователей, если они не вводят значение в поле ввода чисел или вводят недопустимое число. Хотя элемент input type="number" упрощает проверку, допуская только числа и некоторые специальные символы, помните, что все значения, получаемые из HTML-элементов, фактически являются строками. Кроме того, если поле ввода чисел пусто, свойство value будет пустой строкой. Внутри функции checkUserInput используйте оператор if, чтобы проверить, равно ли значение numberInput пустой строке. Тело оператора if пока оставьте пустым.


if (numberInput.value === "") {

};



Шаг 10

В предыдущем проекте вы узнали об истинности и ложности значений, которые могут быть результатом true или false. В JavaScript к ложным значениям часто относятся null, undefined, число 0 и пустые строки. Вместо проверки значения на равенство ложному значению вы можете использовать логический оператор NOT (!) для проверки ложности самого значения. Например:
Пример кода

const num = 0;
console.log(num === 0); // true
console.log(!num); // true

Обновите условие в операторе if, чтобы использовать логический оператор NOT для проверки ложности numberInput.value.


  if (!numberInput.value) {

  }




Шаг 11 Поскольку элемент input type="number" допускает специальные символы, такие как ., + и e, пользователи могут вводить числа с плавающей точкой, например, 2.2, уравнения, например, 2e+3, или даже просто e, что вам не подходит. Хороший способ проверки и нормализации чисел в JavaScript — использовать встроенную функцию parseInt(), которая преобразует строку в целое число. parseInt() принимает как минимум один аргумент — строку, которую нужно преобразовать в целое число, — и возвращает либо целое число, либо NaN (Not a Number). Например:
Пример кода

parseInt(2.2); // 2
parseInt("2e+3"); // 2
parseInt("e") // NaN

Добавьте логический оператор ИЛИ (||) после первого условия в операторе if. Затем передайте значение(value) numberInput в функцию parseInt() в качестве второго условия в операторе if.


  if (!numberInput.value || parseInt(numberInput.value)) {

  }




Шаг 12.

Далее необходимо проверить, является ли возвращаемое функцией parseInt() значение числом. Для этого можно использовать функцию isNaN(). Эта функция принимает строку или число в качестве аргумента и возвращает true, если результат равен NaN. Например:
Пример кода

isNaN("test"); // true
isNaN(2); // false
isNaN("3.5"); // false

Измените второе условие в операторе if, чтобы использовать функцию isNaN() для проверки того, является ли возвращаемое функцией parseInt() значение NaN. Кроме того, как мы упоминали в шаге 1, что мы рассматриваем только положительные числа, необходимо добавить третье условие в оператор if для проверки того, меньше ли число 0 (т.е. отрицательные числа).
Пример кода

6 < 0; // false
-1 < 0; // true
-8 < 0; // true
0 < 0; // false


  if (!numberInput.value || isNaN(parseInt(numberInput.value)) || parseInt(numberInput.value) < 0) {

  }




Шаг 13

Теперь вы можете предупреждать пользователя, если он не ввёл число или число недопустимо, прежде чем пытаться преобразовать его в двоичный код. В теле оператора if используйте метод alert() для отображения текста «Укажите десятичное число, большее или равное 0». Обратите внимание, что alert() — это метод объекта window в браузере, поэтому вы можете использовать как window.alert(), так и alert().




Шаг 14

После оповещения пользователя о том, что введенное число пусто или значение не является числом, вы можете использовать ключевое слово return для преждевременного прерывания этой функции. Это предотвратит выполнение последующего кода в этой функции. Добавьте ключевое слово return после alert().




Шаг 15

Теперь приступим к созданию функции для преобразования десятичных чисел в двоичные. Создайте функцию с именем decimalToBinary и входными(input) данными в качестве параметра. Тело функции пока оставьте пустым.

const decimalToBinary = (input) => {

};




Шаг 16

В функции checkUserInput удалите оператор console.log(). Затем вызовите функцию decimalToBinary и передайте ей значение(value) numberInput в качестве аргумента. Также обязательно используйте функцию parseInt() для преобразования входных данных в число.


decimalToBinary(parseInt(numberInput.value));




Шаг 17

Наконец, необходимо очистить поле ввода чисел, установив его значение в пустую строку. Тогда при последующем преобразовании нескольких чисел подряд вам не придётся удалять предыдущее число перед вводом следующего. Установите свойство value параметра numberInput в пустую строку.


numberInput.value = "";





Шаг 18

Теперь, когда ваша функция настроена, пора познакомиться с двоичными числами. Двоичные числа — это система счисления с основанием 2. В отличие от десятичной системы счисления, которой мы пользуемся каждый день и которая использует 10 цифр (0–9) для записи чисел, двоичная система счисления состоит всего из двух цифр: 0 и 1. В информатике эти двоичные цифры называются битами и представляют собой наименьшую единицу данных, которую может обработать компьютер. Для компьютеров 0 означает «ложь» или «выкл», а 1 — «истина» или «вкл». В функции decimalToBinary используйте ключевое слово return, чтобы вернуть строку, содержащую двоичное представление значения «истина». Примечание: Двоичные числа могут представлять собой длинные последовательности, начинающиеся с 0, поэтому их часто представляют в виде строк.


return "1";





Шаг 19 В двоичной системе счисления самая правая цифра представляет разряд единиц, следующая слева — разряд двойок, затем — разряд четвёрок, затем — разряд восьмёрок и так далее. В этой системе разряд каждой цифры в два раза больше разряда следующей справа от неё. Вот числа от нуля до девяти в десятичной и двоичной системах счисления:
Пример кода

| Base-10 | Base-2 |
| ------- | ------ |
|    0    |  0     |
|    1    |  1     |
|    2    |  10    |
|    3    |  11    |
|    4    |  100   |
|    5    |  101   |
|    6    |  110   |
|    7    |  111   |
|    8    |  1000  |
|    9    |  1001  |

Обратите внимание, что двоичные числа формируются слева направо, от цифры с наибольшим значением слева к наименее значимым справа. Например, число 3 в двоичной системе счисления равно 11, или 1 в разряде двоек и 1 в разряде единиц. Тогда для числа 4 слева добавляется цифра, представляющая разряд четверок, которая устанавливается в 1, разряд двоек равен 0, а разряд единиц равен 0. В функции decimalToBinary преобразуйте число 10 в двоичную систему счисления и верните его в виде строки.


return "1010";





Шаг 20

Биты часто группируются в октет, представляющий собой 8-битный набор, известный как байт. Байт может представлять любое число от 0 до 255. Вот значения размещения каждого бита в байте:
Пример кода

128 | 64 | 32 | 16 | 8 | 4 | 2 | 1

Поскольку биты часто группируются в байты, двоичные числа часто представляются группами по восемь, иногда с ведущими нулями. Например, число 52 можно представить как 110100 или 00110100 с ведущими нулями. Вот как это выглядит с помощью значений размещения:
Пример кода

128 | 64 | 32 | 16 | 8 | 4 | 2 | 1
  0 |  0 |  1 |  1 | 0 | 1 | 0 | 0

В функции decimalToBinary преобразуйте число 118 в двоичную систему с ведущими нулями и верните его в виде строки.


return "01110110";





Шаг 21

Теперь, когда вы знакомы с двоичными числами, пора завершить создание функции для их преобразования. Сначала вы начнёте с более простого решения, а затем преобразуете его в рекурсивное. Сначала вам нужно создать несколько массивов для хранения входных данных и результатов деления, которое вы выполните на следующих шагах. Это упростит понимание того, как работает преобразование из десятичной системы в двоичную. Удалите оператор return из функции decimalToBinary. Затем объявите переменные с именами inputs, quotients и residuals и присвойте каждой из них пустой массив.


  const inputs = [];
  const quotients = [];
  const remainders = [];





Шаг 22

Установите на данный момент input значение равным 0. Мы изменим это в следующих нескольких шагах.


input = 0;




Шаг 23

Для преобразования десятичного числа в двоичное необходимо делить входное число на 2 до тех пор, пока частное, или результат деления двух чисел, не станет равным 0. Но поскольку вы не знаете, сколько раз нужно делить входное число на 2, вы можете использовать цикл while для выполнения блока кода, пока входное число больше 0 и может быть разделено. Напоминаем, что цикл while используется для выполнения блока кода, пока условие выполняется, и условие проверяется перед выполнением блока кода. Например:
Пример кода

let i = 0;

while (i < 5) {
 console.log(i);
 i++;
}

Создайте цикл while, который выполняется, пока входное число(input) больше 0. Оставьте тело цикла пока пустым.


  while (input > 0) {

  }





Шаг 24

Сложность циклов while заключается в том, что при невнимательности они могут выполняться бесконечно. Это называется бесконечным циклом и может привести к сбою браузера. Чтобы избежать бесконечных циклов, необходимо убедиться, что условие цикла while в конечном итоге становится ложным. В этом случае нужно убедиться, что входная переменная в конечном итоге станет равной 0. Переместите оператор input = 0 в тело цикла while. Это позволит циклу выполняться только один раз.





Шаг 25

Для деления чисел в JavaScript используйте оператор деления (/). Например:
Пример кода

const quotient = 5 / 2; // 2.5

В приведённом выше примере 5 — делимое, или число, которое нужно разделить, а 2 — делитель, или число, на которое нужно разделить. Результат, 2.5, называется частным. В цикле while создайте переменную с именем quotient и присвойте ей значение входного значения, делённое на 2.


const quotient = input / 2;





Шаг 26

Как вы видели на предыдущем шаге, деление может привести к получению числа с плавающей точкой или числа с десятичной точкой. Лучший способ решения этой проблемы — округлить до ближайшего целого числа. Используйте функцию Math.floor(), чтобы округлить частное от деления входного значения на 2 до его присвоения переменной quotient.



const quotient = Math.floor(input / 2);





Шаг 27

Теперь, когда у вас есть операция, которая будет уменьшать значение входного значения при каждом выполнении цикла, вам не нужно беспокоиться о том, что цикл будет выполняться вечно. Обновите последнюю строку цикла while и присвойте значение частного(quotient) входному(input) значению.


input = quotient;





Шаг 28

Далее вам нужно вычислить остаток от деления входного значения на 2. Это можно сделать с помощью оператора остатка (%), который возвращает остаток от деления двух чисел. Например:
Пример кода

const remainder = 5 % 2; // 1

Другими словами, делимое 5 можно разделить на делитель 2 несколько раз. В результате получится остаток 1. Внутри цикла while создайте переменную с именем remainder и используйте оператор остатка, чтобы присвоить ей остаток от деления входного значения на 2.


const remainder = input % 2;





Шаг 29

Внутри цикла while используйте метод .push() для добавления входных данных(input) в массив inputs. Это поможет вам лучше понять, как работает преобразование, когда вы будете выводить содержимое массивов в консоль.


inputs.push(input);





Шаг 30

Используйте .push() для добавления переменной quotient к массиву quotients. Также добавьте переменную remainder к массиву remainders.


    quotients.push(quotient);
    remainders.push(remainder);





Шаг 31

Сейчас самое время проверить свою работу. Выведите в консоль текст «Inputs: », запятую и массив inputs.


console.log("Inputs: ", inputs);





Шаг 32

Далее выведите на консоль текст "Quotients: ", запятую и массив quotients. Также выведите на консоль текст "Remainders: ", запятую и массив remainders.


  console.log("Quotients: ", quotients);
  console.log("Remainders: ", remainders);





Шаг 33

Теперь, если ввести число 6 и нажать кнопку «Преобразовать», вы увидите следующий результат:
Пример кода

Inputs:  [ 6, 3, 1 ]
Quotients:  [ 3, 1, 0 ]
Remainders:  [ 0, 1, 1 ]

Обратите внимание, что массив remainders — это двоичное представление числа 6, но в обратном порядке. Используйте метод .reverse(), чтобы изменить порядок элементов массива remainders, и метод .join() с пустой строкой в качестве разделителя, чтобы объединить элементы в двоичную строку. Затем установите result.innerText равным двоичной строке.


result.innerText = remainders.reverse().join("");





Шаг 34

Ваша функция decimalToBinary работает хорошо, но есть проблема: из-за условия в цикле while она работает только для чисел больше 0. Если вы попытаетесь преобразовать 0 в двоичное число, на страницу ничего не добавится. Чтобы исправить это, добавьте оператор if для проверки того, равен ли input 0. Тело оператора if пока оставьте пустым.


if (input === 0) {

}




Шаг 35

В теле оператора if установите свойство innerText объекта result равным строке «0». Затем используйте оператор возврата для раннего выхода из функции.


    result.innerText = "0";
    return;





Шаг 36

Теперь ваша функция decimalToBinary готова. Можете экспериментировать с ней. Но есть несколько способов улучшить её. Например, теперь не нужно отслеживать входные данные и частные. Мы можем сделать функцию более эффективной. Сначала удалите всё из тела функции decimalToBinary. Затем используйте let для создания переменной с именем binary и присвойте ей пустую строку.


let binary = "";





Шаг 37

Поскольку вы хотите отобразить результат преобразования, присвойте binary переменную свойству innerText result в конце функции.


result.innerText = binary;





Шаг 38

Создайте цикл while, который будет выполняться до тех пор, пока  input больше 0. Внутри цикла пока присвойте input 0. Примечание: Будьте внимательны и не вызовите функцию decimalToBinary, пока не присвоите input 0 внутри цикла. В противном случае это может привести к бесконечному циклу.


  while (input > 0) {
    input = 0;
  }





Шаг 39

Напомним, что при каждом выполнении цикла входное значение (input) представляет собой частное от деления предыдущего значения на 2, округлённое в меньшую сторону. В конце концов, входное значение становится меньше 1, и цикл останавливается. Это можно сделать за один шаг. Внутри цикла while установите входное значение равным частному от деления входного значения на 2. Также не забудьте использовать функцию Math.floor() для округления частного в меньшую сторону.


input = Math.floor(input / 2);





Шаг 40

В предыдущей версии этой функции вы помещали остаток входных данных, делённый на 2, в binaryArray. Затем вы разворачивали и объединяли элементы в двоичную числовую строку. Но было бы проще использовать конкатенацию строк внутри цикла для построения двоичной строки справа налево, чтобы вам не пришлось её разворачивать позже. Сначала используйте оператор remainder (%), чтобы установить binary равным остатку input, делённому на 2.


binary = input % 2;





Шаг 41

Затем используйте оператор сложения, чтобы добавить текущее binary значение к концу input % 2. Это позволит построить двоичную строку справа налево.


binary = input % 2 + binary;





Шаг 42

Чтобы немного упростить код, заключите input % 2 в скобки. Иногда это может изменить порядок операций, но в данном случае это просто упростит чтение кода.


binary = (input % 2) + binary;





Шаг 43

Наконец, вам нужно обработать случаи, когда input равны 0. Вместо того, чтобы обновлять DOM и возвращать управление как раньше, вы можете обновить binary и позволить остальной части кода в функции выполниться. Создайте оператор if, который проверяет, равны ли input 0. Если да, установите binary равной строке "0".


if (input ===0) {
  binary = "0";
}





Шаг 44

Отлично! Теперь у вас есть более эффективный способ преобразования десятичных чисел в двоичные. Немного изучив стек вызовов и рекурсию, вы проведёте рефакторинг функции decimalToBinary, используя рекурсию вместо цикла while. Создайте функцию с именем a, которая возвращает следующее: "freeCodeCamp " + b().


const a = () => "freeCodeCamp" + b();

***

const a = () => {
  return "freeCodeCamp " + b();
};





Шаг 45

Далее создайте функцию с именем b, которая возвращает следующее: "is " + c(). Также создайте функцию с именем c, которая возвращает следующее: "awesome!".


const b = () => {
  return "is " + c();
};

const c = () => {
  return "awesome!";
};




 */