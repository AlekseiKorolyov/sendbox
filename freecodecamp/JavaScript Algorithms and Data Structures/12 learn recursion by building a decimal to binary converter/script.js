const numberInput = document.getElementById("number-input");
const convertBtn = document.getElementById("convert-btn");
const result = document.getElementById("result");
const animationData = [
    {
        inputVal: 5,
        addElDelay: 1000
    }
];

const decimalToBinary = (input) => {
    if (input === 0 || input === 1) {
        return String(input);
    } else {
        return decimalToBinary(Math.floor(input / 2)) + (input % 2);
    }
};

const showAnimation = () => {
    setTimeout(() => {
        console.log("free");
    }, 500);
    setTimeout(() => {
        console.log("Code");
    }, 1000);
    setTimeout(() => {
        console.log("Camp");
    }, 1500);
};

const checkUserInput = () => {
    const inputInt = parseInt(numberInput.value);
    if (
        !numberInput.value ||
        isNaN(inputInt) ||
        inputInt < 0
    ) {
        alert("Please provide a decimal number greater than or equal to 0");
        return;
    }

    if (inputInt === 5) {
        showAnimation();
        return;
    }

    result.textContent = decimalToBinary(inputInt);
    numberInput.value = "";
};

convertBtn.addEventListener("click", checkUserInput);

numberInput.addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
        checkUserInput();
    }
});




























/*
Шаг 1

В этом проекте вы создадите десятичную и двоичную систему счисления и познакомитесь с обеими системами счисления. Вы также узнаете о рекурсии, используя её для выполнения преобразований. Весь HTML и CSS для этого проекта предоставлены вам. Когда будете готовы начать, используйте метод .getElementById(), чтобы получить элемент ввода с идентификатором "number-input" и сохранить его в переменной numberInput. Используйте тот же метод, чтобы получить элемент кнопки с идентификатором "convert-btn" и сохранить его в переменной convertBtn, а также элемент вывода с идентификатором "result" и сохранить его в переменной result. ПРИМЕЧАНИЕ: В этом проекте будут преобразованы только положительные числа в двоичные.


const numberInput = document.getElementById("number-input");
const convertBtn = document.getElementById("convert-btn");
const result = document.getElementById("result");



Шаг 2

Теперь нужно настроить проверку значения в поле ввода числа при каждом нажатии пользователем кнопки «Преобразовать». Сначала создайте пустую функцию с именем checkUserInput.


const checkUserInput = () => {};




Шаг 3

Хороший способ проверить работоспособность — вывести значение атрибута value элемента numberInput на консоль. Напоминаем, что доступ к значению атрибута value элемента можно получить, используя точку или скобки. В функции checkUserInput используйте console.log() для выведения значения numberInput на консоль.


console.log(numberInput.value);




Шаг 4

Теперь, когда функция checkUserInput() настроена для тестирования, вы можете использовать прослушиватель событий для вызова функции при нажатии кнопки «Конвертировать». Свяжите метод .addEventListener() с convertBtn. Прослушиватель событий должен отслеживать события нажатия и принимать ссылку на функцию checkUserInput в качестве обратного вызова. Помните, что ссылки на функции не вызываются в скобках. После этого при каждом нажатии кнопки «Конвертировать» значение введённого числа должно выводиться в консоль.


convertBtn.addEventListener("click", checkUserInput);




Шаг 5

Кнопка «Преобразовать» теперь должна работать. Но пользователям может быть утомительно вводить число, а затем нажимать эту кнопку каждый раз, когда нужно преобразовать его из десятичного формата в двоичный. Было бы гораздо удобнее выполнять преобразование при нажатии клавиши Enter или Return. Событие keydown срабатывает каждый раз, когда пользователь нажимает клавишу на клавиатуре, и это хороший способ добавить больше интерактивности элементам ввода. Добавьте .addEventListener() к numberInput. Обработчик событий должен отслеживать события keydown и принимать пустую стрелочную функцию в качестве обратного вызова.


numberInput.addEventListener("keydown", () => {});




Шаг 6

Всякий раз, когда прослушиватель событий срабатывает при возникновении события, автоматически создаётся объект события. Этот объект не всегда требуется использовать, как в случае с обработчиком щелчков, описанным выше, но он может быть полезен для доступа к информации о сработавшем событии. Сначала передайте e в качестве параметра функции обратного вызова. Помните, что e — это общее имя параметра для объекта события. Затем выведите e в консоль в теле функции обратного вызова.


numberInput.addEventListener("keydown", (e) => {
  console.log(e);
});




Шаг 7

Если вы откроете консоль браузера и введёте число, вы увидите объекты событий, зарегистрированные в браузере. Если вы внимательно изучите один из этих объектов событий, вы увидите полезные свойства, такие как type и target. Поскольку вы хотите выполнить действие при нажатии клавиши Enter, наиболее полезным свойством будет key, которое возвращает строковое значение нажатой клавиши. Удалите оператор console.log() из функции обратного вызова и добавьте оператор if, который проверяет, равен ли e.key строке «Enter». Тело оператора if пока оставьте пустым. Примечание: поскольку клавиши Enter и Return выполняют схожие функции, они имеют одинаковое строковое значение «Enter».


  if (e.key === "Enter") {

  }




Шаг 8.

Далее, в теле оператора if вызовите функцию checkUserInput(). После этого, если ввести числа в поле ввода и нажать клавишу Enter/Return, вы увидите числа, выведенные на консоль.


checkUserInput();




Шаг 9

Теперь, когда кнопка «Конвертировать» и поле ввода чисел отслеживают нажатия клавиш Enter и клики, пора завершить функцию checkUserInput(). Было бы полезно предупреждать пользователей, если они не вводят значение в поле ввода чисел или вводят недопустимое число. Хотя элемент input type="number" упрощает проверку, допуская только числа и некоторые специальные символы, помните, что все значения, получаемые из HTML-элементов, фактически являются строками. Кроме того, если поле ввода чисел пусто, свойство value будет пустой строкой. Внутри функции checkUserInput используйте оператор if, чтобы проверить, равно ли значение numberInput пустой строке. Тело оператора if пока оставьте пустым.


if (numberInput.value === "") {

};



Шаг 10

В предыдущем проекте вы узнали об истинности и ложности значений, которые могут быть результатом true или false. В JavaScript к ложным значениям часто относятся null, undefined, число 0 и пустые строки. Вместо проверки значения на равенство ложному значению вы можете использовать логический оператор NOT (!) для проверки ложности самого значения. Например:
Пример кода

const num = 0;
console.log(num === 0); // true
console.log(!num); // true

Обновите условие в операторе if, чтобы использовать логический оператор NOT для проверки ложности numberInput.value.


  if (!numberInput.value) {

  }




Шаг 11 Поскольку элемент input type="number" допускает специальные символы, такие как ., + и e, пользователи могут вводить числа с плавающей точкой, например, 2.2, уравнения, например, 2e+3, или даже просто e, что вам не подходит. Хороший способ проверки и нормализации чисел в JavaScript — использовать встроенную функцию parseInt(), которая преобразует строку в целое число. parseInt() принимает как минимум один аргумент — строку, которую нужно преобразовать в целое число, — и возвращает либо целое число, либо NaN (Not a Number). Например:
Пример кода

parseInt(2.2); // 2
parseInt("2e+3"); // 2
parseInt("e") // NaN

Добавьте логический оператор ИЛИ (||) после первого условия в операторе if. Затем передайте значение(value) numberInput в функцию parseInt() в качестве второго условия в операторе if.


  if (!numberInput.value || parseInt(numberInput.value)) {

  }




Шаг 12.

Далее необходимо проверить, является ли возвращаемое функцией parseInt() значение числом. Для этого можно использовать функцию isNaN(). Эта функция принимает строку или число в качестве аргумента и возвращает true, если результат равен NaN. Например:
Пример кода

isNaN("test"); // true
isNaN(2); // false
isNaN("3.5"); // false

Измените второе условие в операторе if, чтобы использовать функцию isNaN() для проверки того, является ли возвращаемое функцией parseInt() значение NaN. Кроме того, как мы упоминали в шаге 1, что мы рассматриваем только положительные числа, необходимо добавить третье условие в оператор if для проверки того, меньше ли число 0 (т.е. отрицательные числа).
Пример кода

6 < 0; // false
-1 < 0; // true
-8 < 0; // true
0 < 0; // false


  if (!numberInput.value || isNaN(parseInt(numberInput.value)) || parseInt(numberInput.value) < 0) {

  }




Шаг 13

Теперь вы можете предупреждать пользователя, если он не ввёл число или число недопустимо, прежде чем пытаться преобразовать его в двоичный код. В теле оператора if используйте метод alert() для отображения текста «Укажите десятичное число, большее или равное 0». Обратите внимание, что alert() — это метод объекта window в браузере, поэтому вы можете использовать как window.alert(), так и alert().




Шаг 14

После оповещения пользователя о том, что введенное число пусто или значение не является числом, вы можете использовать ключевое слово return для преждевременного прерывания этой функции. Это предотвратит выполнение последующего кода в этой функции. Добавьте ключевое слово return после alert().




Шаг 15

Теперь приступим к созданию функции для преобразования десятичных чисел в двоичные. Создайте функцию с именем decimalToBinary и входными(input) данными в качестве параметра. Тело функции пока оставьте пустым.

const decimalToBinary = (input) => {

};




Шаг 16

В функции checkUserInput удалите оператор console.log(). Затем вызовите функцию decimalToBinary и передайте ей значение(value) numberInput в качестве аргумента. Также обязательно используйте функцию parseInt() для преобразования входных данных в число.


decimalToBinary(parseInt(numberInput.value));




Шаг 17

Наконец, необходимо очистить поле ввода чисел, установив его значение в пустую строку. Тогда при последующем преобразовании нескольких чисел подряд вам не придётся удалять предыдущее число перед вводом следующего. Установите свойство value параметра numberInput в пустую строку.


numberInput.value = "";





Шаг 18

Теперь, когда ваша функция настроена, пора познакомиться с двоичными числами. Двоичные числа — это система счисления с основанием 2. В отличие от десятичной системы счисления, которой мы пользуемся каждый день и которая использует 10 цифр (0–9) для записи чисел, двоичная система счисления состоит всего из двух цифр: 0 и 1. В информатике эти двоичные цифры называются битами и представляют собой наименьшую единицу данных, которую может обработать компьютер. Для компьютеров 0 означает «ложь» или «выкл», а 1 — «истина» или «вкл». В функции decimalToBinary используйте ключевое слово return, чтобы вернуть строку, содержащую двоичное представление значения «истина». Примечание: Двоичные числа могут представлять собой длинные последовательности, начинающиеся с 0, поэтому их часто представляют в виде строк.


return "1";





Шаг 19 В двоичной системе счисления самая правая цифра представляет разряд единиц, следующая слева — разряд двойок, затем — разряд четвёрок, затем — разряд восьмёрок и так далее. В этой системе разряд каждой цифры в два раза больше разряда следующей справа от неё. Вот числа от нуля до девяти в десятичной и двоичной системах счисления:
Пример кода

| Base-10 | Base-2 |
| ------- | ------ |
|    0    |  0     |
|    1    |  1     |
|    2    |  10    |
|    3    |  11    |
|    4    |  100   |
|    5    |  101   |
|    6    |  110   |
|    7    |  111   |
|    8    |  1000  |
|    9    |  1001  |

Обратите внимание, что двоичные числа формируются слева направо, от цифры с наибольшим значением слева к наименее значимым справа. Например, число 3 в двоичной системе счисления равно 11, или 1 в разряде двоек и 1 в разряде единиц. Тогда для числа 4 слева добавляется цифра, представляющая разряд четверок, которая устанавливается в 1, разряд двоек равен 0, а разряд единиц равен 0. В функции decimalToBinary преобразуйте число 10 в двоичную систему счисления и верните его в виде строки.


return "1010";





Шаг 20

Биты часто группируются в октет, представляющий собой 8-битный набор, известный как байт. Байт может представлять любое число от 0 до 255. Вот значения размещения каждого бита в байте:
Пример кода

128 | 64 | 32 | 16 | 8 | 4 | 2 | 1

Поскольку биты часто группируются в байты, двоичные числа часто представляются группами по восемь, иногда с ведущими нулями. Например, число 52 можно представить как 110100 или 00110100 с ведущими нулями. Вот как это выглядит с помощью значений размещения:
Пример кода

128 | 64 | 32 | 16 | 8 | 4 | 2 | 1
  0 |  0 |  1 |  1 | 0 | 1 | 0 | 0

В функции decimalToBinary преобразуйте число 118 в двоичную систему с ведущими нулями и верните его в виде строки.


return "01110110";





Шаг 21

Теперь, когда вы знакомы с двоичными числами, пора завершить создание функции для их преобразования. Сначала вы начнёте с более простого решения, а затем преобразуете его в рекурсивное. Сначала вам нужно создать несколько массивов для хранения входных данных и результатов деления, которое вы выполните на следующих шагах. Это упростит понимание того, как работает преобразование из десятичной системы в двоичную. Удалите оператор return из функции decimalToBinary. Затем объявите переменные с именами inputs, quotients и residuals и присвойте каждой из них пустой массив.


  const inputs = [];
  const quotients = [];
  const remainders = [];





Шаг 22

Установите на данный момент input значение равным 0. Мы изменим это в следующих нескольких шагах.


input = 0;




Шаг 23

Для преобразования десятичного числа в двоичное необходимо делить входное число на 2 до тех пор, пока частное, или результат деления двух чисел, не станет равным 0. Но поскольку вы не знаете, сколько раз нужно делить входное число на 2, вы можете использовать цикл while для выполнения блока кода, пока входное число больше 0 и может быть разделено. Напоминаем, что цикл while используется для выполнения блока кода, пока условие выполняется, и условие проверяется перед выполнением блока кода. Например:
Пример кода

let i = 0;

while (i < 5) {
 console.log(i);
 i++;
}

Создайте цикл while, который выполняется, пока входное число(input) больше 0. Оставьте тело цикла пока пустым.


  while (input > 0) {

  }





Шаг 24

Сложность циклов while заключается в том, что при невнимательности они могут выполняться бесконечно. Это называется бесконечным циклом и может привести к сбою браузера. Чтобы избежать бесконечных циклов, необходимо убедиться, что условие цикла while в конечном итоге становится ложным. В этом случае нужно убедиться, что входная переменная в конечном итоге станет равной 0. Переместите оператор input = 0 в тело цикла while. Это позволит циклу выполняться только один раз.





Шаг 25

Для деления чисел в JavaScript используйте оператор деления (/). Например:
Пример кода

const quotient = 5 / 2; // 2.5

В приведённом выше примере 5 — делимое, или число, которое нужно разделить, а 2 — делитель, или число, на которое нужно разделить. Результат, 2.5, называется частным. В цикле while создайте переменную с именем quotient и присвойте ей значение входного значения, делённое на 2.


const quotient = input / 2;





Шаг 26

Как вы видели на предыдущем шаге, деление может привести к получению числа с плавающей точкой или числа с десятичной точкой. Лучший способ решения этой проблемы — округлить до ближайшего целого числа. Используйте функцию Math.floor(), чтобы округлить частное от деления входного значения на 2 до его присвоения переменной quotient.



const quotient = Math.floor(input / 2);





Шаг 27

Теперь, когда у вас есть операция, которая будет уменьшать значение входного значения при каждом выполнении цикла, вам не нужно беспокоиться о том, что цикл будет выполняться вечно. Обновите последнюю строку цикла while и присвойте значение частного(quotient) входному(input) значению.


input = quotient;





Шаг 28

Далее вам нужно вычислить остаток от деления входного значения на 2. Это можно сделать с помощью оператора остатка (%), который возвращает остаток от деления двух чисел. Например:
Пример кода

const remainder = 5 % 2; // 1

Другими словами, делимое 5 можно разделить на делитель 2 несколько раз. В результате получится остаток 1. Внутри цикла while создайте переменную с именем remainder и используйте оператор остатка, чтобы присвоить ей остаток от деления входного значения на 2.


const remainder = input % 2;





Шаг 29

Внутри цикла while используйте метод .push() для добавления входных данных(input) в массив inputs. Это поможет вам лучше понять, как работает преобразование, когда вы будете выводить содержимое массивов в консоль.


inputs.push(input);





Шаг 30

Используйте .push() для добавления переменной quotient к массиву quotients. Также добавьте переменную remainder к массиву remainders.


    quotients.push(quotient);
    remainders.push(remainder);





Шаг 31

Сейчас самое время проверить свою работу. Выведите в консоль текст «Inputs: », запятую и массив inputs.


console.log("Inputs: ", inputs);





Шаг 32

Далее выведите на консоль текст "Quotients: ", запятую и массив quotients. Также выведите на консоль текст "Remainders: ", запятую и массив remainders.


  console.log("Quotients: ", quotients);
  console.log("Remainders: ", remainders);





Шаг 33

Теперь, если ввести число 6 и нажать кнопку «Преобразовать», вы увидите следующий результат:
Пример кода

Inputs:  [ 6, 3, 1 ]
Quotients:  [ 3, 1, 0 ]
Remainders:  [ 0, 1, 1 ]

Обратите внимание, что массив remainders — это двоичное представление числа 6, но в обратном порядке. Используйте метод .reverse(), чтобы изменить порядок элементов массива remainders, и метод .join() с пустой строкой в качестве разделителя, чтобы объединить элементы в двоичную строку. Затем установите result.innerText равным двоичной строке.


result.innerText = remainders.reverse().join("");





Шаг 34

Ваша функция decimalToBinary работает хорошо, но есть проблема: из-за условия в цикле while она работает только для чисел больше 0. Если вы попытаетесь преобразовать 0 в двоичное число, на страницу ничего не добавится. Чтобы исправить это, добавьте оператор if для проверки того, равен ли input 0. Тело оператора if пока оставьте пустым.


if (input === 0) {

}




Шаг 35

В теле оператора if установите свойство innerText объекта result равным строке «0». Затем используйте оператор возврата для раннего выхода из функции.


    result.innerText = "0";
    return;





Шаг 36

Теперь ваша функция decimalToBinary готова. Можете экспериментировать с ней. Но есть несколько способов улучшить её. Например, теперь не нужно отслеживать входные данные и частные. Мы можем сделать функцию более эффективной. Сначала удалите всё из тела функции decimalToBinary. Затем используйте let для создания переменной с именем binary и присвойте ей пустую строку.


let binary = "";





Шаг 37

Поскольку вы хотите отобразить результат преобразования, присвойте binary переменную свойству innerText result в конце функции.


result.innerText = binary;





Шаг 38

Создайте цикл while, который будет выполняться до тех пор, пока  input больше 0. Внутри цикла пока присвойте input 0. Примечание: Будьте внимательны и не вызовите функцию decimalToBinary, пока не присвоите input 0 внутри цикла. В противном случае это может привести к бесконечному циклу.


  while (input > 0) {
    input = 0;
  }





Шаг 39

Напомним, что при каждом выполнении цикла входное значение (input) представляет собой частное от деления предыдущего значения на 2, округлённое в меньшую сторону. В конце концов, входное значение становится меньше 1, и цикл останавливается. Это можно сделать за один шаг. Внутри цикла while установите входное значение равным частному от деления входного значения на 2. Также не забудьте использовать функцию Math.floor() для округления частного в меньшую сторону.


input = Math.floor(input / 2);





Шаг 40

В предыдущей версии этой функции вы помещали остаток входных данных, делённый на 2, в binaryArray. Затем вы разворачивали и объединяли элементы в двоичную числовую строку. Но было бы проще использовать конкатенацию строк внутри цикла для построения двоичной строки справа налево, чтобы вам не пришлось её разворачивать позже. Сначала используйте оператор remainder (%), чтобы установить binary равным остатку input, делённому на 2.


binary = input % 2;





Шаг 41

Затем используйте оператор сложения, чтобы добавить текущее binary значение к концу input % 2. Это позволит построить двоичную строку справа налево.


binary = input % 2 + binary;





Шаг 42

Чтобы немного упростить код, заключите input % 2 в скобки. Иногда это может изменить порядок операций, но в данном случае это просто упростит чтение кода.


binary = (input % 2) + binary;





Шаг 43

Наконец, вам нужно обработать случаи, когда input равны 0. Вместо того, чтобы обновлять DOM и возвращать управление как раньше, вы можете обновить binary и позволить остальной части кода в функции выполниться. Создайте оператор if, который проверяет, равны ли input 0. Если да, установите binary равной строке "0".


if (input ===0) {
  binary = "0";
}





Шаг 44

Отлично! Теперь у вас есть более эффективный способ преобразования десятичных чисел в двоичные. Немного изучив стек вызовов и рекурсию, вы проведёте рефакторинг функции decimalToBinary, используя рекурсию вместо цикла while. Создайте функцию с именем a, которая возвращает следующее: "freeCodeCamp " + b().


const a = () => "freeCodeCamp" + b();

***

const a = () => {
  return "freeCodeCamp " + b();
};





Шаг 45

Далее создайте функцию с именем b, которая возвращает следующее: "is " + c(). Также создайте функцию с именем c, которая возвращает следующее: "awesome!".


const b = () => {
  return "is " + c();
};

const c = () => {
  return "awesome!";
};





Шаг 46

Наконец, вызовите a() из оператора console.log(), чтобы вывести вывод на консоль.


console.log(a());





Шаг 47

В информатике стек — это структура данных, в которой элементы хранятся по принципу LIFO (последним пришёл — первым ушёл). Если представить себе стопку книг, то последняя книга, добавленная в стопку, будет первой книгой, которую можно извлечь из неё. Или массив, в котором можно использовать только методы .push() и .pop(). Стек вызовов — это набор вызовов функций, хранящихся в стековой структуре. При вызове функции она добавляется на вершину стека, а при возврате из неё — удаляется с вершины/конца стека. Вы увидите это в действии, создав фиктивный стек вызовов. Инициализируйте переменную с именем callStack и присвойте ей пустой массив.


const callStack = [];





Шаг 48

При запуске кода функция a() добавляется в стек вызовов первой. В массиве callStack добавьте следующую строку: 'a(): returns "freeCodeCamp " + b()'. Это представляет вызов функции и код, который будет выполнен. Примечание: Поскольку добавляемая строка содержит двойные кавычки ("), заключите её в одинарные кавычки (') или обратные кавычки (`).


const callStack = [
'a(): returns "freeCodeCamp " + b()'
];





Шаг 49

Затем, поскольку a() вызывает b(), функция b() добавляется в стек вызовов. Затем добавьте следующую строку в массив callStack: "b(): returns 'is ' + c()". Помните, что стек вызовов — это структура данных LIFO, поэтому последняя функция добавляется в начало или конец стека, аналогично добавлению элемента в массив.


const callStack = [
  'a(): returns "freeCodeCamp " + b()',
  'b(): returns "is " + c()'
];





Шаг 50

И поскольку b() вызывает c(), функция c() добавляется в стек вызовов. Добавьте следующую строку в массив callStack: "c(): returns 'awesome!'".


const callStack = [
  'a(): returns "freeCodeCamp " + b()',
  'b(): returns "is " + c()',
  'c(): returns "awesome!"'
];





Шаг 51

Ваш стек вызовов готов. Как видите, a() находится внизу или в начале стека, который вызывает b() в середине, который вызывает c() вверху или в конце. Как только все вызовы будут на своих местах, они начнут выполняться сверху вниз. c() выполняется, возвращает строку "awesome!" и удаляется с вершины стека. Удалите строку "c(): returns 'awesome!" из вершины массива callStack.





Шаг 52

Затем функция b() выполняется и возвращает результат "is " + "awesome!". Обновите ваш фиктивный вызов b() так, чтобы он выглядел так: "b(): возвращает 'is ' + 'awesome!".


const callStack = [
  'a(): returns "freeCodeCamp " + b()',
  'b(): returns "is " + "awesome!"'
];





Шаг 53

Теперь, когда b() выполнился, удалите его из стека вызовов. Затем обновите ваш фиктивный вызов a() следующим образом: «a(): returns 'freeCodeCamp ' + 'is awesome!'».


const callStack = [
  'a(): returns "freeCodeCamp " +"is awesome!"',
];





Шаг 54

Наконец, a() возвращает объединённую строку «freeCodeCamp is awesome!». Удалить a() из вершины стека вызовов.





Шаг 55

Хотя это простой пример, он демонстрирует, как стек вызовов проходит по вашему коду и вызывает несколько функций. Теперь пора перейти к рекурсии и посмотреть, как стек вызовов вписывается в общую картину. Удалите массив callStack, функции a(), b() и c(), а также оператор console.log().





Шаг 56

Теперь вам нужно создать функцию, которая будет вести обратный отсчёт от заданного числа до нуля, используя рекурсию. Создайте новую функцию с именем countdown и параметром number. Тело функции пока оставьте пустым.


const countdown = (number) => {

};





Шаг 57

Первое, что вам нужно сделать, — это вывести текущее значение number на консоль, чтобы использовать его в качестве обратного отсчёта. Используйте console.log() для вывода number на консоль.


console.log(number);





Шаг 58

Рекурсивная функция — это функция, которая вызывает себя снова и снова. Но будьте осторожны, так как можно легко создать бесконечный цикл. Именно здесь вступает в действие базовый случай. Базовый случай — это когда функция перестаёт вызывать себя, и рекомендуется написать его первым. Поскольку ваша функция countdown() будет отсчитывать от заданного числа до нуля, базовый случай — когда параметр number равен 0. В этом случае функция должна вернуться, чтобы выйти из рекурсивного цикла. Используйте оператор if, чтобы проверить, равно ли значение number нулю. Если да, используйте ключевое слово return, чтобы выйти из функции.


  if (number === 0) {
    return;
  }




Шаг 59

Рекурсивные функции также имеют рекурсивный случай, когда функция вызывает сама себя. Сначала преобразуйте оператор if в оператор if...else. Тело оператора else пока оставьте пустым.


  if (number === 0) {
    return;
  } else {

  }




Шаг 60

При написании рекурсивного варианта необходимо помнить о двух вещах:
    1 Какой базовый вариант?
    2 Какой минимальный объём работы нужно выполнить, чтобы приблизиться к базовому варианту?
Поскольку базовый вариант — это когда number равно 0, необходимо снова вызвать countdown(), одновременно уменьшив значение number на 1. Внутри блока else вызовите countdown() и передайте ему number - 1 в качестве аргумента.


  if (number === 0) {
    return;
  } else {
    countdown(number - 1);
  }





Шаг 61

Пора протестировать функцию. Вызовите countdown() с аргументом 3, чтобы проверить её работоспособность.


countdown(3);





Шаг 62

Чтобы увидеть стек вызовов в действии, нужно лишь немного изменить функцию. Сначала переименуйте функцию countdown() в countDownAndUp(). Не забудьте также обновить вызовы функций.





Шаг 63

В базовом варианте выведите на консоль сообщение «Достигнут базовый вариант».





Шаг 64

Затем выведите number на консоль после рекурсивного вызова функции countDownAndUp(number - 1).





Шаг 65

Теперь вы должны увидеть обратный отсчёт от 3 до 0, за которым следует Reached base case и счётчик от 1 до 3. Это связано с тем, что после завершения рекурсивного цикла функция продолжит выполнение кода после рекурсивного вызова. Именно поэтому вы видите Reached base case перед счётчиком от 1 до 3. Теперь, когда вы лучше понимаете, как работает стек вызовов и рекурсия, вы проведёте рефакторинг функции decimalToBinary(), чтобы использовать рекурсию вместо цикла while. Сначала удалите функцию countDownAndUp() и её вызов.





Шаг 66 Затем удалите содержимое функции decimalToBinary(). Тело функции пока оставьте пустым.





Шаг 67

Напоминаем, что при написании рекурсивной функции часто лучше начинать с базового случая, чтобы понимать, к чему стремитесь, и избежать бесконечного цикла. Как и в предыдущей реализации, вы будете многократно делить input на 2, пока input не станут равны 0. Используйте оператор if, чтобы проверить, равны ли input 0. Если да, верните пустую строку.


if (input === 0) {
  return "";
}





Шаг 68

Для рекурсивного случая добавьте оператор else и верните результат вызова decimalToBinary(). Передайте input, делённые на 2 и округлённые в меньшую сторону, используя Math.floor() в качестве аргумента.


 else {
    return decimalToBinary(Math.floor(input / 2));
  }





Шаг 69

Это фактически уменьшает input примерно вдвое при каждом вызове функции decimalToBinary(). Однако помните, что строка двоичных чисел формируется путём вычисления остатка от деления input на 2 и добавления его в конец строки. После вызова decimalToBinary() используйте оператор сложения (+), чтобы присоединить остаток от деления input на 2 к концу строки, возвращаемой рекурсивной функцией. Также заключите операцию в скобки.


return decimalToBinary(Math.floor(input / 2)) + (input % 2);





Шаг 70

Наконец, в функции checkUserInput() установите свойство textContent результата равным строке, возвращаемой функцией decimalToBinary().


result.textContent = decimalToBinary(parseInt(numberInput.value));





Шаг 71

Ваш конвертер должен работать. Можете свободно экспериментировать с разными числами и размышлять о том, что происходит каждый раз при вызове decimalToBinary(). Но если вы протестируете конвертер с 0, вы увидите, что ничего не происходит. Это связано с тем, что в базовом варианте возвращается пустая строка, когда входное значение равно 0. Мы можем исправить это сейчас. Обновите базовый вариант так, чтобы он возвращал строку «0», когда входное значение равно 0.





Шаг 72

В основном это работает: если преобразовать 0 в двоичную систему счисления, на странице отображается 0. Но теперь при преобразовании других чисел больше 0 двоичная система счисления начинается с 0. Например, если преобразовать 1, результат будет 01. Но если задуматься, 0 и 1 в десятичной системе счисления всегда преобразуются в 0 и 1 в двоичной соответственно. Поэтому можно добавить ещё один базовый случай для обработки входных данных, равных 1. Добавьте в функцию оператор else if, который проверяет, равно ли входное значение 1. Если да, возвращает строку «1».


 else if (input === 1) {
    return "1";
  }





Шаг 73

Теперь всё должно работать как надо. Поскольку на данном этапе вы знаете, что input будут либо 0, либо 1, вы можете объединить два базовых варианта и просто вернуть input в виде строки. Для надёжного преобразования значения в строку, даже ложных значений, таких как null и undefined, можно использовать функцию String(). Например: Пример кода

const num = 5;
console.log(String(num)); // "5"
console.log(String(null)); // "null"

Объедините операторы if и else if в один оператор if, проверяющий, равен ли входной параметр 0 или 1. Если да, используйте функцию String() для преобразования входных данных в строку и её возврата.


if (input === 0 || input === 1) {
    return String(input);
  }





Шаг 74

Теперь ваша функция decimalToBinary() готова. Можете смело протестировать её. Если вы всё ещё не понимаете, как она работает, не волнуйтесь. Далее вы создадите простую анимацию, которая поможет вам понять, что происходит на каждом этапе. Создайте новую функцию с именем showAnimation. Пока оставьте тело функции пустым.


const showAnimation = () => {};





Шаг 75

Вы будете показывать анимацию, когда пользователи попытаются преобразовать десятичное число 5 в двоичное, поэтому вам нужно добавить проверку этого в функцию checkUserInput(). Используйте оператор if, чтобы проверить, равен ли атрибут value объекта numberInput числу 5. Не забудьте использовать функцию parseInt() для преобразования строки в число перед сравнением её с 5. Пока оставьте оператор if пустым.


if (parseInt(numberInput.value) === 5) {}





Шаг 76

Если значение numberInput равно 5, вызвать функцию showAnimation(), а затем выполнить ранний возврат.


showAnimation();
return;





Шаг 77

Теперь ваша функция showAnimation() настроена. Но если вы посмотрите на функцию checkUserInput(), вы заметите, что она вызывает parseInt() для преобразования numberInput.value в число несколько раз. Как правило, это плохая практика, например, по причинам производительности или просто потому, что вам придётся менять логику в нескольких местах для обновления вызова parseInt(). Чтобы исправить это, создайте новую переменную для хранения преобразованного числа. Тогда вам нужно будет преобразовать число только один раз, и вы сможете использовать его во всей функции. Создайте новую переменную с именем inputInt и присвойте ей число, преобразованное из numberInput.value.


const inputInt = parseInt(numberInput.value);





Шаг 78

Замените все вхождения parseInt(numberInput.value) на inputInt.





Шаг 79

Теперь, когда функция showAnimation() настроена, давайте проведём тестирование. Добавьте три оператора console.log() в функцию showAnimation() для вывода на консоль текстов «free», «Code» и «Camp». Вы должны увидеть этот текст в консоли, когда введёте число 5 в поле ввода и нажмёте кнопку «Преобразовать».





Шаг 80

Прежде чем начать писать код для анимации, давайте рассмотрим функцию setTimeout, которую вы будете использовать для добавления и удаления элементов из DOM. Функция setTimeout принимает два аргумента: функцию обратного вызова и число в миллисекундах, представляющее собой время ожидания перед выполнением функции обратного вызова. Например, если вы хотите вывести на консоль сообщение «Hello, world!» через 3 секунды, вы должны написать:
Пример кода

setTimeout(() => {
 console.log("Hello, world!");
 }, 3000);

 Используйте функцию setTimeout, чтобы добавить задержку в одну секунду перед выводом текста «Code» на консоль. Затем посмотрите, что произойдет после ввода числа 5 в поле ввода и нажатия кнопки «Convert».


   setTimeout(() => {
    console.log("Code");
  }, 1000);





Шаг 81

Если вы протестируете свой код, вы заметите, что записи в консольных журналах отображаются не в ожидаемом порядке. Вместо записи «free», паузы на секунду перед записью «Code» и, наконец, записи «Camp», вы увидите следующее: Пример кода free Camp Код Это связано с тем, что функция setTimeout() асинхронна, то есть не останавливает выполнение остального кода. Весь код в функции showAnimation() выполняется построчно, но поскольку setTimeout() асинхронна, записи «free» и «Camp» выводятся на консоль немедленно, а затем запись «Code» выводится на консоль с задержкой в одну секунду. Один из способов исправить это — использовать несколько функций setTimeout(). Используйте setTimeout() для записи «free» на консоль через полсекунды, или 500 миллисекунд.


setTimeout(() => {
    console.log("free");
  }, 500);





Шаг 82 Хотя асинхронный (или асинхронный) код может показаться сложным для понимания поначалу, у него есть множество преимуществ. Одно из самых важных заключается в том, что он позволяет писать неблокирующий код. Например, представьте, что вы печёте торт, ставите его в духовку и устанавливаете таймер. Вам не нужно всё время сидеть перед духовкой в ожидании — вы можете мыть посуду, читать книгу или заниматься чем-то ещё, ожидая таймера. Асинхронный код работает аналогично. Вы можете запустить асинхронную операцию, и другие части вашего кода продолжат работать, пока она выполняется. Вы узнаете больше об асинхронном коде в будущих проектах, но функция setTimeout() — хорошее введение. Добавьте задержку в 1500 миллисекунд перед выводом текста «Camp» в консоль.


  setTimeout(() => {
    console.log("Camp");
  }, 1500);





Шаг 83

Теперь вы готовы приступить к самой анимации. Вы будете использовать массив объектов для хранения данных для каждого кадра анимации. Сначала создайте новую переменную с именем animationData и присвойте ей пустой массив.





Шаг 84

Далее вам нужно создать объект, представляющий первый кадр анимации. У вашего объекта должно быть два свойства или ключа: inputVal и addElDelay. inputVal будет представлять значение входных данных при каждом запуске рекурсивной функции. А addElDelay — задержку между добавлением элементов DOM на страницу. Добавьте объект в animationData со свойством inputVal, равным 5, и свойством addElDelay, равным 1000.


{
  inputVal: 5,
  addElDelay: 1000
}








 */