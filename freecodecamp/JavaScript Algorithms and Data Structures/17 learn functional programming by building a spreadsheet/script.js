const infixToFunction = {
    "+" : (x, y) => x + y,
    "-": (x, y) => x - y,
    "*": (x, y) => x * y,
    "/": (x, y) => x / y,
};

const infixEval = (str, regex) => str.replace(regex, (_match, arg1, operator, arg2) => infixToFunction[operator](parseFloat(arg1), parseFloat(arg2)));

const highPrecedence = str => {
    const regex = /^\d+[*\/\d+$]/;
    const str2 = infixEval(str, regex);
    return str === str2 ? str : highPrecedence(str2);
};

const isEven = (num) => num % 2 === 0;
const sum = (nums) => nums.reduce((acc, el) => acc + el);
const average = (nums) => sum(nums) / nums.length;

const median = (nums) => {
    const sorted = nums.slice().sort((a, b) => a - b);
    const length = sorted.length;
    const middle = length / 2 - 1;
    return isEven(length)
        ? average([sorted[middle], sorted[middle + 1]])
        : sorted[Math.ceil(middle)];
};

const spreadsheetFunctions = {
    sum,
    average,
    median,
};

const applyFunction = str => {
    const noHigh = highPrecedence(str);
    const infix = /([\d.]+)([+-])([\d.]+)/;
};

const range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);
const charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map((code) => String.fromCharCode(code));

const evalFormula = (x, cells) => {
    const idToText = (id) => cells.find(cell => cell.id === id ).value;
    const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;
    const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));
    const elemValue = num => character => idToText(character + num);
    const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));
    const rangeExpanded = x.replace(rangeRegex, (_match, char1, num1, char2, num2) => rangeFromString(num1, num2).map(addCharacters(char1)(char2)));
    const cellRegex = /[A-J][1-9][0-9]?/gi;
    const cellExpanded = rangeExpanded.replace(cellRegex, match => idToText(match.toUpperCase()));
}

window.onload =  () => {
    const container = document.getElementById("container");
    const createLabel = (name) => {
        const label = document.createElement("div");
        label.className = "label";
        label.textContent = name;
        container.appendChild(label);
    };
    const letters = charRange("A", "J");
    letters.forEach(createLabel);
    range(1, 99).forEach(number => {
        createLabel(number)
        letters.forEach((letter) => {
            const input = document.createElement("input");
            input.type = "text";
            input.id = letter + number;
            input.ariaLabel = letter + number;
            input.onchange = update;
            container.appendChild(input);
        });
    });
};

const update = (event) => {
    const element = event.target;
    const value = element.value.replace(/\s/g, "");
    if (!value.includes(element.id) && value.startsWith('=')) {

    }
};





























/*
Шаг 1

Ваш проект начинается с базового HTML-контейнера и соответствующего CSS. Ваша первая задача — программно сгенерировать ячейки для вашей электронной таблицы. Глобальный объект window представляет собой окно браузера (или вкладку). Он имеет свойство onload, которое позволяет определить поведение после загрузки всей страницы окном, включая таблицы стилей и скрипты. Начните с установки свойства onload объекта window в стрелочную функцию без параметров. В функции объявите переменную container и присвойте ей значение, полученное путем получения элемента по идентификатору "container".


window.onload =  () => {
  const container = document.getElementById("container");
};




Шаг 2

Функции идеально подходят для многократно используемой логики. Когда самой функции необходимо повторно использовать логику, можно объявить вложенную функцию для обработки этой логики. Вот пример вложенной функции:
Пример кода

const outer = () => {
 const inner = () => {
  };
 };

Объявите вложенную функцию createLabel, используя стрелочный синтаксис. Она должна принимать параметр name.


  const createLabel = (name) => {

  };




Шаг 3

Помните, что у объекта документа есть метод `.createElement()`, который позволяет динамически создавать новые HTML-элементы. В функции `createLabel` объявите переменную `label` и присвойте ей новый элемент `div`.


const label = document.createElement("div");




Шаг 4

Установите для элемента label значение className равным "label", а для параметра textContent — значение name.


  label.className = "label";
  label.textContent = name;





Шаг 5

Наконец, используйте метод `.appendChild()`, чтобы добавить элемент label к элементу container.


container.appendChild(label);




Шаг 6

Вам понадобится функция для генерации диапазона чисел. Объявите пустую функцию range, которая принимает параметры start и end. Используйте конструктор Array() и неявно верните пустой массив.


const range = (start, end) => Array();




Шаг 7 Размер вашего массива должен соответствовать размеру диапазона. Вы можете вычислить это, найдя разницу между end и start и добавив 1 к результату. Передайте это вычисление в качестве аргумента конструктору Array().


end - start + 1




Шаг 8

Конструктор Array() имеет метод .fill(), который можно использовать для заполнения массива значением. Вы можете использовать его для заполнения массива start значением. Привяжите метод .fill() к конструктору Array() и передайте ему start значение.


const range = (start, end) => Array(end - start + 1).fill(start);




Шаг 9

В настоящее время ваша функция range возвращает массив правильной длины, но все значения в нем равны значению переменной start. Чтобы это исправить, свяжите метод .map() с вашим методом .fill(). Передайте методу .map() функцию обратного вызова, которая принимает в качестве параметров element и index и возвращает сумму этих параметров.


const range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);




Шаг 10

Теперь, когда у вас есть функция range, вы можете использовать ее и для создания диапазона букв. Объявите функцию charRange, используя синтаксис const и стрелка. Она должна принимать параметры start и end. Функция должна неявно возвращать результат вызова функции range() с аргументами start и end.


const charRange = (start, end) => range(start, end);




Шаг 11

Ваша функция range ожидает числа, но начальное и конечное значения будут строками (в частности, это будут отдельные символы, например, A). Преобразуйте начальное и конечное значения в вызове range() в числа, используя метод .charCodeAt(), передав в качестве аргумента этому методу число 0.


const charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0));




Шаг 12

Функция range() вернет массив чисел, которые вам нужно преобразовать обратно в символы. Привяжите метод .map() к вызову range(). Передайте функцию обратного вызова, которая принимает code в качестве параметра и неявно возвращает значение переданного code методу String.fromCharCode().


const charRange = (start, end) => range(
  start.charCodeAt(0), end.charCodeAt(0)).map((code) => String.fromCharCode(code));




Шаг 13

Теперь, когда ваши вспомогательные функции готовы, в обработчике события onload вам следует объявить переменную letters. Присвойте ей результат вызова функции charRange() с буквами "A" и "J" в качестве аргументов.


const letters = charRange("A", "J");




Шаг 14

Теперь вызовите метод `.forEach()` вашего массива letters и передайте ссылку на функцию `createLabel` в качестве функции обратного вызова. Вы должны увидеть несколько букв в верхней части вашей электронной таблицы.


letters.forEach(createLabel);




Шаг 15

Помните, что метод range() возвращает массив, поэтому вы можете напрямую привязывать методы массивов к вызову функции. Вызовите метод range() с аргументами 1 и 99 и вызовите метод .forEach(). Передайте методу .forEach() пустую функцию обратного вызова, которая принимает number в качестве параметра.


range(1, 99).forEach((number) => {});




Шаг 16

В функции обратного вызова вам потребуется сделать два вызова. Начните с вызова функции createLabel() и передайте в качестве аргумента number. Вы должны увидеть несколько чисел в вашей электронной таблице. Затем вызовите метод .forEach() для вашего массива letters. Передайте пустую функцию обратного вызова, которая принимает параметр в виде letter.


    createLabel(number)
    letters.forEach((letter) => {});




Шаг 17

Теперь во вложенном вызове метода .forEach() объявите input переменную. Используйте метод .createElement() объекта document для создания элемента input. Установите атрибут type в значение "text", а атрибут id — в значение "letter + number".


      const input = document.createElement("input");
      input.type = "text";
      input.id = letter + number;




Шаг 18

В предыдущих проектах вы изучили метод setAttribute. Другой способ обновить атрибут в JavaScript — использовать следующий синтаксис:
Пример кода

el.attribute = value;

Названия свойств для значений HTML-атрибутов с дефисом, таких как aria-label, следуют верблюжьему регистру и становятся ariaLabel.
Пример кода

el.ariaLabel = "Значение метки Aria";

Установите атрибут aria-label для элемента input на то же значение, что и атрибут id.


input.ariaLabel = letter + number;




Шаг 19

Добавьте элемент input к вашему элементу container в качестве дочернего элемента. Теперь вы должны видеть ячейки вашей электронной таблицы.


container.appendChild(input);




Шаг 20

Большинство программ для работы с электронными таблицами включают встроенные функции для вычислений. Объявите функцию sum, которая принимает параметр nums, представляющий собой массив чисел. Она должна возвращать результат вызова функции reduce для этого массива, суммирующего все числа.


const sum = (nums) => nums.reduce((acc, el) => acc + el);




Шаг 21

Объявите функцию isEven, которая принимает параметр num и возвращает true, если число четное, и false в противном случае. Используйте оператор деления по модулю % для определения того, является ли число четным или нечетным.


const isEven = (num) => num % 2 === 0 ? true : false;




Шаг 22

Объявите average функцию  вычисления среднего значения, которая принимает массив чисел в качестве параметра nums. Она должна возвращать среднее арифметическое всех чисел в массиве. Среднее значение можно вычислить, разделив сумму всех чисел в массиве на длину массива. Помните, что у вас есть функция sum, которую вы можете использовать.


const average = (nums) => sum(nums) / nums.length;




Шаг 23

Следующая функция вычислит медианное значение массива чисел. Начните с объявления стрелочной функции median вычисления медианы, которая принимает параметр типа nums. В функции объявите переменную sorted и присвойте ей значение отсортированной копии массива nums. Для создания поверхностной копии массива следует использовать метод slice().


const median = (nums) => {
  const sorted = nums.slice().sort((a, b) => a - b);
  };




Шаг 24

Теперь объявите переменную length и присвойте ей длину отсортированного массива, а также middle переменная, значение которой равно длине, деленной на 2, вычтено 1.


  const length = sorted.length;
  const middle = length / 2 - 1;




Шаг 25

Проверьте, является ли length четной, используя функцию isEven. Если да, верните middle в середине списка и числа после него. Если оно нечетное, верните middle в середине списка — вам нужно будет округлить middle в большую сторону.



return isEven(length) ? average([sorted[middle], sorted[middle + 1]]) : sorted[Math.ceil(middle)];




Шаг 26

Свойства объекта состоят из пар ключ/значение. При объявлении литерала объекта можно использовать сокращенные имена свойств. При использовании сокращенного синтаксиса имен свойств имя переменной становится ключом свойства, а ее значение — значением свойства. В следующем примере объявляется объект пользователя со свойствами userId, firstName и loggedIn.
Пример кода

const userId = 1;
const firstName = "John";
const loggedIn = true;
const user = {
 userId,
 firstName,
 loggedIn,
};
console.log(user); // { userId: 1, firstName: 'John', loggedIn: true }

Чтобы отслеживать все функции вашей электронной таблицы, объявите объект spreadsheetFunctions. Используя сокращенный синтаксис, установите sum, average и median в качестве свойств объекта spreadsheetFunctions.


const spreadsheetFunctions = {
  sum,
  average,
  median,
};




Шаг 27

Теперь вы можете начать использовать функции электронных таблиц. Для начала объявите стрелочную функцию update. Она должна принимать параметр event.


const update = (event) => {};




Шаг 28

В функции window.onload необходимо указать элементам input вызывать функцию update при изменении значения. Это можно сделать, напрямую установив свойство onchange. Установите свойство onchange как ссылку на вашу функцию update.


input.onchange = update;




Шаг 29

Поскольку ваше событие update выполняется как обработчик события change, параметр события будет представлять собой событие изменения. Свойство target события изменения представляет собой элемент, который изменился. Присвойте свойство target новой переменной с именем element.

const element = event.target;




Шаг 30

Поскольку событие change срабатывает на элементе input, у этого элемента будет свойство `value`, представляющее текущее значение поля ввода. Присвойте свойство `value` element новой переменной с именем `value` и используйте метод `.replace()` для удаления всех пробелов.


const value = element.value.replace(/\s/g, "");




Шаг 31

Теперь вам нужно проверить, не содержит ли value id элемента. Для этого создайте условие if.


  if (!value.includes(element.id)) {

  }




Шаг 32

В программах для работы с электронными таблицами обычно используется знак "=" в начале ячейки, указывающий на необходимость выполнения вычисления и оценки функций электронных таблиц. Используйте оператор &&, чтобы добавить второе условие в оператор if, которое также проверяет, является ли первый символ value "=". Вы можете использовать [0], .startsWith() или .charAt(0).


if (!value.includes(element.id) && value[0] === "=")

***

value.startsWith('=')




Шаг 33

Для выполнения функций электронной таблицы вам необходимо уметь анализировать и оценивать входную строку. Сейчас самое время использовать другую функцию. Объявите стрелочную функцию evalFormula, которая принимает параметры x и cells.


const evalFormula = (x, cells) => {};




Шаг 34

В вашем evalFormula объявите стрелочную функцию idToText, которая принимает параметр id. Ваша функция idToText должна возвращать результат вызова метода .find() для массива cells с функцией обратного вызова, которая принимает параметр cell и возвращает cell.id === id. Обе ваши функции должны использовать неявное возвращение.


const idToText = (id) => cells.find(cell => cell.id === id );




Шаг 35

Ваша функция idToText в настоящее время возвращает элемент input. Обновите ее, чтобы она возвращала value этого элемента input.


const idToText = id => cells.find(cell => cell.id === id).value




Шаг 36

Вам необходимо уметь сопоставлять диапазоны ячеек в формуле. Диапазоны ячеек могут выглядеть как A1:B12 или A3:A25. Для сопоставления этих шаблонов можно использовать регулярное выражение. Начните с объявления переменной rangeRegex и присвойте ей регулярное выражение, которое соответствует диапазону от A до J (диапазон столбцов в вашей электронной таблице). Для этого используйте группу захвата с символьным классом.


const rangeRegex = /([A-J])/;




Шаг 37

После успешного сопоставления буквы ячейки ваш rangeRegex должен сопоставить номер ячейки. Номера ячеек на вашем листе варьируются от 1 до 99. Добавьте группу захвата после группы захвата буквы. Ваша новая группа захвата должна соответствовать одной или двум цифрам – первая цифра должна быть от 1 до 9, а вторая – от 0 до 9. Вторая цифра должна быть необязательной.


const rangeRegex = /([A-J])([1-9][0-9]?)/;




Шаг 38

Диапазоны разделены двоеточием. После двух групп захвата ваше регулярное выражение для диапазонов должно искать двоеточие.


const rangeRegex = /([A-J])([1-9][0-9]?):/




Шаг 39

После того, как ваше регулярное выражение rangeRegex найдет двоеточие, ему необходимо найти тот же шаблон из букв и цифр, что и раньше. Скопируйте две существующие группы захвата и вставьте их после двоеточия.


const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/;




Шаг 40

Наконец, сделайте ваш rangeRegex глобальным и нечувствительным к регистру.


const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;




Шаг 41 Объявите стрелочную функцию rangeFromString, которая принимает два параметра: num1 и num2. Функция должна неявно возвращать результат вызова функции range с аргументами num1 и num2. Для большей безопасности преобразуйте num1 и num2 в целые числа при передаче их в функцию range.


const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));




Шаг 42

Объявите функцию elemValue, которая принимает параметр типа num. Функция должна быть пустой.


const elemValue = (num) => {};




Шаг 43

В функции elemValue объявите функцию с именем inner, которая принимает параметр character. Затем верните вашу inner функцию.


    const inner = (character) => {

    };
    return inner;




Шаг 44

В вашей внутренней функции верните результат вызова функции idToText с аргументом character + num.


return idToText(character + num);




Шаг 45

Концепция возврата функции внутри функции называется каррированием. Этот подход позволяет создать переменную, которая будет содержать функцию, вызываемую позже, но со ссылкой на параметры вызова внешней функции. Например:
Пример кода

const innerOne = elemValue(1);
const final = innerOne("A");

innerOne будет вашей внутренней функцией, где num будет установлено равным 1, а final будет содержать значение ячейки с идентификатором "A1". Это возможно, потому что функции имеют доступ ко всем переменным, объявленным при их создании. Это называется замыканием. Вы получите дополнительную практику в этом. Объявите функцию addCharacters, которая принимает параметр character1.


const addCharacters = (character1) => {};




Шаг 46

В вашей функции elemValue вы явно объявили функцию с именем inner и вернули её. Однако, поскольку вы используете стрелочный синтаксис, вы можете неявно вернуть функцию.
Например:

Пример кода const curry = soup => veggies => {};

curry — это функция, которая принимает параметр soup и возвращает функцию, которая принимает параметр veggies. Используя этот синтаксис, обновите вашу функцию addCharacters, чтобы она возвращала пустую функцию, которая принимает параметр character2.


  const addCharacters = character1 => character2 => {

  }




Шаг 47

Ваши внутренние функции также могут возвращать функцию. Используя тот же синтаксис стрелок, обновите функцию addCharacters, чтобы она возвращала третью функцию, которая принимает параметр типа num.


  const addCharacters = character1 => character2 => num => {

  }




Шаг 48

Теперь обновите самую внутреннюю функцию в цепочке addCharacters, чтобы она неявно возвращала результат вызова charRange() с аргументами character1 и character2.


const addCharacters = character1 => character2 => num => charRange(character1, character2);




Шаг 49

Используйте тот же синтаксис, что и для функции addCharacters, чтобы обновить функцию elemValue. Она больше не должна объявлять inner, а должна неявно возвращать функцию.


const elemValue = num => character => idToText(character + num);




Шаг 50

Ваша функция addCharacters в конечном итоге возвращает диапазон символов. Вам нужно, чтобы она возвращала массив идентификаторов ячеек. Привяжите метод .map() к вызову charRange(). Пока не передавайте функцию обратного вызова.


const addCharacters = character1 => character2 => num => charRange(character1, character2).map()




Шаг 51

Вы можете передать ссылку на функцию в качестве параметра обратного вызова. Ссылка на функцию — это имя функции без скобок. Например:
Пример кода

const myFunc = (val) => `value: ${val}`;
const array = [1, 2, 3];
const newArray = array.map(myFunc);

Метод .map() здесь вызовет функцию myFunc, передав те же аргументы, что и метод обратного вызова .map(). Первый аргумент — это значение массива на текущей итерации, поэтому newArray будет [value: 1, value: 2, value: 3]. Передайте ссылку на вашу функцию elemValue в качестве обратного вызова для вашего метода .map().


const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue);




Шаг 52

Поскольку elemValue возвращает функцию, ваша функция addCharacters в конечном итоге возвращает массив ссылок на функции. Вам нужно, чтобы метод .map() запускал внутреннюю функцию вашей функции elemValue, а это значит, что вам нужно вызывать elemValue, а не ссылаться на нее. Передайте num в качестве аргумента вашей функции elemValue.


const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));




Шаг 53 Объявите переменную rangeExpanded и присвойте ей результат вызова метода .replace() вашего параметра x. Передайте переменную rangeRegex в качестве аргумента.


const rangeExpanded = x.replace(rangeRegex);




Шаг 54

Второй аргумент метода `.replace()` не обязательно должен быть строкой. Вместо этого вы можете передать функцию обратного вызова для выполнения более сложной логики над найденной строкой. Функция обратного вызова принимает несколько параметров. Первый — это найденная строка. Передайте пустую функцию обратного вызова в вызов `.replace()` и укажите в качестве параметра `match`.


const rangeExpanded = x.replace(rangeRegex, (match) => {});




Шаг 55

Функция обратного вызова должна иметь параметр для каждой группы захвата в регулярном выражении. В вашем случае rangeRegex имеет четыре группы захвата: первая буква, первые цифры, вторая буква и вторые цифры. Добавьте в функцию обратного вызова еще четыре параметра для сопоставления этих групп захвата: char1, num1, char2 и num2. char — это сокращение от character (символ).


const rangeExpanded = x.replace(rangeRegex, (match, char1, num1, char2, num2) => {});




Шаг 56

Ваш коллбэк должен неявно возвращать результат вызова функции rangeFromString() с аргументами num1 и num2.


const rangeExpanded = x.replace(rangeRegex, (match, char1, num1, char2, num2) => rangeFromString(num1, num2));




Шаг 57

Вызовите метод .map() в вызове rangeFromString(), передав ссылку на addCharacters в качестве функции обратного вызова.


rangeFromString(num1, num2).map(addCharacters)




Шаг 58

Функция addCharacters возвращает функцию, поэтому вам нужно будет её вызвать. Передайте char1 в качестве аргумента


addCharacters(char1)




Шаг 59

Ваш вызов addCharacters(char1) также возвращает функцию, которая возвращает другую функцию. Вам необходимо сделать еще один вызов функции, чтобы получить доступ к самой внутренней ссылке на функцию для обратного вызова .map(). JavaScript позволяет немедленно вызывать возвращаемые функции:
Пример кода

myFunc(1)("hi");

Немедленно вызовите функцию, возвращаемую вашим вызовом addCharacters(char1), и передайте char2 в качестве аргумента.


addCharacters(char1)(char2)




Шаг 60

Теперь, когда ваша функция `.map()` получает ссылку на функцию `num => charRange(...).map(...)`, возвращаемую каррированными вызовами `addCharacters`, она будет корректно перебирать элементы и передавать каждый элемент в качестве `n` этой функции. Вы заметите, что не используете параметр `match`. В JavaScript принято добавлять префикс `_` перед неиспользуемым параметром. Вы также можете оставить параметр пустым, например: `(, char1)`, но часто понятнее назвать параметр для удобства чтения в будущем. Добавьте префикс `--` перед параметром `match`.


rangeRegex, (_match, char1, num1, char2, num2)




Шаг 61

Объявите переменную cellRegex для сопоставления ссылок на ячейки. Она должна соответствовать букве от A до J, за которой следует цифра от 1 до 9 и необязательная цифра от 0 до 9. Сделайте регулярное выражение регистронечувствительным и глобальным.


const cellRegex = /[A-J][1-9][0-9]?/gi;




Шаг 62

Объявите переменную cellExpanded и присвойте ей значение вызова метода .replace() для вашей переменной rangeExpanded. Передайте ей ваше регулярное выражение cellRegex и пустую функцию обратного вызова. Функция обратного вызова должна принимать параметр match.


const cellExpanded = rangeExpanded.replace(cellRegex, (match) => {});




Шаг 63

Обновите свою функцию обратного вызова, чтобы она возвращала результат вызова idToText() с аргументом match. Помните, что ваше регулярное выражение нечувствительно к регистру, поэтому вам нужно будет вызвать toUpperCase() для match перед передачей его в idToText().


const cellExpanded = rangeExpanded.replace(cellRegex, match => idToText(match.toUpperCase()));




Шаг 64

В математике инфикс — это математический оператор, который располагается между двумя своими операндами. Например, 1 + 2 — это инфиксное выражение. Для разбора этих выражений вам потребуется сопоставить символы с соответствующими функциями. Объявите переменную infixToFunction и присвойте ей пустой объект.


const infixToFunction = {};




Шаг 65

Значения объекта не обязательно должны быть примитивными типами, такими как строка или число. Они также могут быть функциями. Добавьте к вашему объекту infixToFunction свойство +. Это свойство должно быть функцией, которая принимает параметры x и y и неявно возвращает сумму этих двух параметров. Поскольку + не является буквенно-цифровым символом, вам нужно будет заключить его в кавычки для вашего свойства.


const infixToFunction = {
  "+" : (x, y) => x + y
};




Шаг 66

Теперь создайте свойство - , которое представляет собой функцию, принимающую параметры x и y и неявно возвращающую результат вычитания y из x.


"-": (x, y) => x - y,




Шаг 67

Следуя тому же принципу, добавьте свойство для умножения * и деления / с соответствующими функциями.


  "*": (x, y) => x * y,
  "/": (x, y) => x / y,




Шаг 68

Теперь, когда у вас есть инфиксные функции, вам нужен способ их вычисления. Объявите функцию infixEval, которая принимает два параметра: str и regex. Она должна неявно возвращать метод .replace() функции str, передавая в качестве аргументов regex и пустую функцию обратного вызова.


const infixEval = (str, regex) => str.replace(regex, () => {});




Шаг 69

Ваш функции обратного вызова необходимо четыре параметра: match, arg1, operator и arg2. Параметр match использовать не нужно, поэтому не забудьте добавить его в начало.


str.replace(regex, (_match, arg1, operator, arg2) => {});




Шаг 70

regex, которое вы будете передавать в функцию infixEval, будет соответствовать двум числам с оператором между ними. Первое число будет присвоено переменной arg1 в функции обратного вызова, второе — arg2, а operator — оператору. Ваша функция обратного вызова должна неявно возвращать свойство operator объекта infixToFunction. Помните, что operator — это переменная, которая хранит имя свойства, а не фактическое имя свойства.


infixToFunction[operator])




Шаг 71

infixToFunction[operator] возвращает функцию. Вызовите эту функцию напрямую, передав arg1 и arg2 в качестве аргументов.


infixToFunction[operator](arg1, arg2)




Шаг 72

У вас небольшая ошибка. arg1 и arg2 — это строки, а не числа. Функция infixToFunction['+']("1", "2") вернет 12, что математически некорректно. Оберните каждый из аргументов infixToFunction[operator] в вызов parseFloat().


infixToFunction[operator](parseFloat(arg1), parseFloat(arg2)))




Шаг 73

Теперь, когда вы умеете вычислять математические выражения, вам необходимо учитывать порядок выполнения операций. Объявите функцию highPrecedence, которая принимает параметр типа str.


const highPrecedence = str => {};




Шаг 74

В вашей функции highPrecedence объявите переменную с помощью const и присвойте ей регулярное выражение, которое проверяет, соответствует ли строка, переданная в качестве параметра str, шаблону: число, за которым следует оператор * или /, а затем еще одно число. Ваша функция должна возвращать логическое значение. Помните, что для этого можно использовать метод test().


const highPrecedence = str => {
  const regex = /^\d+[*\/\d+$]/;
  return regex.test(str);
}




Шаг 75

Для вывода результата вызова функции highPrecedence со строкой "5*3" следует использовать console.log().

console.log(highPrecedence("5*3"));




Шаг 76

Удалите из функции highPrecedence как console.log(), так и оператор return.




Шаг 77

Теперь, когда у вас есть регулярное выражение для сопоставления умножения или деления, вы можете вычислить это выражение. Объявите переменную типа str2 и присвойте ей результат вызова функции infixEval с аргументами str и regex.

const str2 = infixEval(str, regex);




Шаг 78

Ваша функция infixEval будет оценивать только первую операцию умножения или деления, поскольку регулярные выражения не являются глобальными. Это означает, что вам следует использовать рекурсивный подход для оценки всей строки. Если infixEval не найдет совпадений, она вернет значение str как есть. Используя тернарное выражение, проверьте, равно ли str2 значению str. Если да, верните str, в противном случае верните результат вызова highPrecedence() для str2.


return str === str2 ? str : highPrecedence(str2);




Шаг 79

Теперь вы можете начать применять логику разбора функции к строке. Объявите функцию с именем applyFunction, которая принимает параметр типа str.

const applyFunction = str => {};




Шаг 80

Сначала вам нужно обработать операторы с более высоким приоритетом. Объявите переменную noHigh и присвойте ей результат вызова функции highPrecedence() с аргументом str.

const noHigh = highPrecedence(str);




Шаг 81

Теперь, когда вы проанализировали и оценили операторы умножения и деления, вам нужно сделать то же самое с операторами сложения и вычитания. Объявите инфиксную переменную и присвойте ей регулярное выражение, которое соответствует числу (включая десятичные числа), за которым следует оператор + или -, а затем другое число.

const infix = /([\d.]+)([+-])([\d.]+)/;



















105
*/