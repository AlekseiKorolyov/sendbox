const range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);
const charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map((code) => String.fromCharCode(code));

window.onload =  () => {
    const container = document.getElementById("container");
    const createLabel = (name) => {
        const label = document.createElement("div");
        label.className = "label";
        label.textContent = name;
        container.appendChild(label);
    };
    const letters = charRange("A", "J");
};





























/*
Шаг 1

Ваш проект начинается с базового HTML-контейнера и соответствующего CSS. Ваша первая задача — программно сгенерировать ячейки для вашей электронной таблицы. Глобальный объект window представляет собой окно браузера (или вкладку). Он имеет свойство onload, которое позволяет определить поведение после загрузки всей страницы окном, включая таблицы стилей и скрипты. Начните с установки свойства onload объекта window в стрелочную функцию без параметров. В функции объявите переменную container и присвойте ей значение, полученное путем получения элемента по идентификатору "container".


window.onload =  () => {
  const container = document.getElementById("container");
};




Шаг 2

Функции идеально подходят для многократно используемой логики. Когда самой функции необходимо повторно использовать логику, можно объявить вложенную функцию для обработки этой логики. Вот пример вложенной функции:
Пример кода

const outer = () => {
 const inner = () => {
  };
 };

Объявите вложенную функцию createLabel, используя стрелочный синтаксис. Она должна принимать параметр name.


  const createLabel = (name) => {

  };




Шаг 3

Помните, что у объекта документа есть метод `.createElement()`, который позволяет динамически создавать новые HTML-элементы. В функции `createLabel` объявите переменную `label` и присвойте ей новый элемент `div`.


const label = document.createElement("div");




Шаг 4

Установите для элемента label значение className равным "label", а для параметра textContent — значение name.


  label.className = "label";
  label.textContent = name;





Шаг 5

Наконец, используйте метод `.appendChild()`, чтобы добавить элемент label к элементу container.


container.appendChild(label);




Шаг 6

Вам понадобится функция для генерации диапазона чисел. Объявите пустую функцию range, которая принимает параметры start и end. Используйте конструктор Array() и неявно верните пустой массив.


const range = (start, end) => Array();




Шаг 7 Размер вашего массива должен соответствовать размеру диапазона. Вы можете вычислить это, найдя разницу между end и start и добавив 1 к результату. Передайте это вычисление в качестве аргумента конструктору Array().


end - start + 1




Шаг 8

Конструктор Array() имеет метод .fill(), который можно использовать для заполнения массива значением. Вы можете использовать его для заполнения массива start значением. Привяжите метод .fill() к конструктору Array() и передайте ему start значение.


const range = (start, end) => Array(end - start + 1).fill(start);




Шаг 9

В настоящее время ваша функция range возвращает массив правильной длины, но все значения в нем равны значению переменной start. Чтобы это исправить, свяжите метод .map() с вашим методом .fill(). Передайте методу .map() функцию обратного вызова, которая принимает в качестве параметров element и index и возвращает сумму этих параметров.


const range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);




Шаг 10

Теперь, когда у вас есть функция range, вы можете использовать ее и для создания диапазона букв. Объявите функцию charRange, используя синтаксис const и стрелка. Она должна принимать параметры start и end. Функция должна неявно возвращать результат вызова функции range() с аргументами start и end.


const charRange = (start, end) => range(start, end);




Шаг 11

Ваша функция range ожидает числа, но начальное и конечное значения будут строками (в частности, это будут отдельные символы, например, A). Преобразуйте начальное и конечное значения в вызове range() в числа, используя метод .charCodeAt(), передав в качестве аргумента этому методу число 0.


const charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0));




Шаг 12

Функция range() вернет массив чисел, которые вам нужно преобразовать обратно в символы. Привяжите метод .map() к вызову range(). Передайте функцию обратного вызова, которая принимает code в качестве параметра и неявно возвращает значение переданного code методу String.fromCharCode().


const charRange = (start, end) => range(
  start.charCodeAt(0), end.charCodeAt(0)).map((code) => String.fromCharCode(code));




Шаг 13

Теперь, когда ваши вспомогательные функции готовы, в обработчике события onload вам следует объявить переменную letters. Присвойте ей результат вызова функции charRange() с буквами "A" и "J" в качестве аргументов.


const letters = charRange("A", "J");












*/