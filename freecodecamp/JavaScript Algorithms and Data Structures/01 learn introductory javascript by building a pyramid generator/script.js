const character = "!";
const count = 10;
const rows = [];
let inverted = false;

function padRow(rowNumber, rowCount) {
    return " ".repeat(rowCount - rowNumber) + character.repeat(2 * rowNumber - 1) + " ".repeat(rowCount - rowNumber);
}

for (let i = 1; i <= count; i++) {
    if (inverted) {
        rows.unshift(padRow(i, count));
    } else {
        rows.push(padRow(i, count));
    }
}

let result = ""

for (const row of rows) {
    result = result + row + "\n";
}

console.log(result);














/*
 node script1.js

for...of


for (let i = 1; i <= count; i ++) {
     rows.push(padRow(i, count));
 }


const numbers = [1, 2, 3];
const shifted = numbers.shift();
console.log(shifted);
const unshifted = numbers.unshift(5);
console.log(numbers);
console.log(unshifted);

  .shift().  удаляет первый элемент массива
const numbers = [1, 2, 3];
numbers.shift();

 Метод массива .unshift() позволяет добавить значение в начало массива
  .unshift() возвращает новую длину массива, для которого он был вызван.
const countDown = [2, 1, 0];
const newLength = countDown.unshift(3);
console.log(countDown); // [3, 2, 1, 0]
console.log(newLength); // 4


for (let i = count; false; false)
let i = count итератор с присвоением значения
условие false
итерация false


 while (continueLoop) {
     done++;
     rows.push(padRow(done, count));
      if (done === count) {
        continueLoop = false;
     }
 }

 done++;  используется без пробела

 if ("") {
     console.log("Condition is true");
 } else if (5 > 10) {
     console.log("5 is less than 10");
 } else {
     console.log("This is the else block");
 }



Создайте оператор if с логическим значением true в качестве условия. В теле оператора выведите строку «Условие истинно».
 if (true) {
     console.log("Condition is true");
 }





 function padRow(rowNumber, rowCount) {                        функция padRow возвращает значение символьной переменной, повторяющееся rowNumber раз
     return " " + character.repeat(rowNumber)  + " ";          " " + character + " " добавляет по одному пробелу « » в начало и конец повторяющейся строки символов.
     return " ".repeat(rowCount - rowNumber) + character.repeat(rowNumber) + " ".repeat(rowCount - rowNumber);   повторяет rowCount - rowNumber раз
 }



 function padRow(name) {                               создание функции padRow
     const test = "Testing";           Переменные объявленные внутри функции считаются находящимися в локальной области видимости, или области видимости блока. Переменная, объявленная внутри функции, может использоваться только внутри этой функции.
     return name;                                       По умолчанию функции возвращают undefined в качестве своего значения. Чтобы вернуть что-то другое, необходимо использовать ключевое слово return
 }                                                     код после return не работает
 const call = padRow("AIK");                            вызов функцю padRow
 console.log(call);

 for (let i = 0; i < count; i = i + 1) {
     rows.push(i);                                    помещает i в массив строк.
     rows.push(character.repeat(i + 1));           помещает переменную в массив строк
 }                                                       .repeat(i) Этот метод принимает число в качестве аргумента, указывающее количество повторений целевой строки переменная i представляет собой текущий номер «строки» в вашем цикле
 повторение строки ноль раз не приводит к выводу каких-либо данных. Чтобы исправить это, добавьте 1 к значению i в вызове .repeat()
 let result = "";

 for (const row of rows) {                           цикл for...of перебирает каждый элемент итерируемого объекта и временно присваивает его переменной
     result = row + result + "\n";                   hello = hello + "World"; добавит строку "World" к существующей строке, хранящейся в переменной hello. Это называется конкатенацией.
 }                                                    + "\n"   переносит элемент массива на новую строку   интерпретируется как новая строка при записи строки в журнал

 console.log(result);

 function addTwoNumbers(firstName, lastName) {    создаю функцию с двумя аргументами
     return firstName + lastName;                 возвращается сумма двух аргументов
 }

 const sum = addTwoNumbers(5, 10);                объявляется переменная sum и вызывает функцию
 console.log(sum);                                выводит в кансоль значение sum

for (iterator; condition; iteration) {
   logic;
 }
 Пример кода for (итератор; условие; итерация) { логика; }

 let rows = ["Naomi", "Quincy", "CamperChan"];
 rows.push("freeCodeCamp");           метод .push() позволяет «поместить» значение в конец массива
 let pushed = rows.push();
 console.log(pushed);
 let popped = rows.pop();            метод .pop() удаляет последний элемент из массива и возвращает этот элемент
 console.log(popped);
 console.log(rows);
 console.log(rows[0]);
 rows[rows.length - 1] = 10;          .length изменяет последний элемент массива (возвращает количество элементов в массиве вычитая 1)

Шаг 16.

 С числовым типом данных можно выполнять математические операции, например, сложение. Попробуйте вывести на консоль значение count + 1. Вы также можете выполнять вычитание (-), умножение (*) и деление (/).

let character = 'Hello';
let count = 8;
console.log(count + 1);

Объявите переменную rows и присвойте ей пустой массив
let rows = [];

Когда массив содержит значения или элементы, эти значения разделяются запятыми.
 Пример кода
 let array = ["first", "second"];

 Шаг 20.

  Вы можете получить доступ к значениям внутри массива, используя индекс значения. Индекс — это число, представляющее позицию значения в массиве, начиная с 0 для первого значения. Вы можете получить доступ к значению, используя квадратные скобки, например, array[0]. Используйте console.log и квадратные скобки, чтобы вывести первое значение в массиве строк.

let character = 'Hello';
let count = 8;
let rows = ["Naomi", "Quincy", "CamperChan"];
console.log(rows[0]);

Шаг 21.

 Особенность массивов заключается в том, что они считаются изменяемыми. Это означает, что вы можете напрямую изменять значение по индексу. Например, этот код присвоит число 25 второму элементу массива:
Пример кода
let array = [1, 2, 3];
array[1] = 25;
console.log(array);  выводит [1, 25, 3]

Обновите третий элемент массива rows, установив его равным 10. Затем выведите массив rows на консоль.

let rows = ["Naomi", "Quincy", "CamperChan"];
rows[2] = 10;
console.log(rows);  [ 'Naomi', 'Quincy', 10 ]

Шаг 22.

 Заметили, как значение в вашем массиве rows было напрямую изменено? Это называется мутацией. По мере изучения массивов вы будете понимать, когда следует изменять массив, а когда нет. Прежде чем двигаться дальше, это отличная возможность изучить распространённое использование массивов. В настоящее время ваш код обращается к последнему элементу массива с помощью rows[2]. Но вы можете не знать, сколько элементов в массиве, когда вам нужен последний. Вы можете использовать свойство .length массива — оно возвращает количество элементов в массиве. Чтобы получить последний элемент любого массива, используйте следующий синтаксис:

array[array.length - 1]

Функция array.length возвращает количество элементов в массиве. Вычитая 1, вы получаете индекс последнего элемента в массиве. Эту же концепцию можно применить к массиву rows. Обновите rows[2], чтобы динамически получить доступ к последнему элементу в массиве rows.

rows[rows.length - 1] = 10;


Шаг 24.

 На последних нескольких шагах вы изучили всё о работе с массивами. Уделите немного времени повторению пройденного материала. Начните с объявления переменной cities и инициализации её как массива строк «London», «New York» и «Mumbai». Затем выведите эту переменную в консоль. После записи в консоль измените последний элемент cities на строку «Mexico City», а затем снова выведите переменную cities. Если всё сделано правильно, вы должны увидеть следующий вывод в консоли.
Example Code
[ "London", "New York", "Mumbai" ]
[ "London", "New York", "Mexico City" ]

let cities = ["London", "New York", "Mumbai"];
console.log(cities);
cities[cities.length - 1] = "Mexico City";
console.log(cities);

Шаг 26.

 Метод в JavaScript — это функция, связанная с определёнными значениями или объектами. Пример, с которым вы уже сталкивались, — метод .log(), являющийся частью объекта console. У массивов есть свои собственные методы, и первым из них вы изучите метод .push(). Он позволяет «поместить» значение в конец массива. Вот пример добавления числа 12 в конец массива: Пример кода

array.push(12);

Используйте .push(), чтобы добавить строку «freeCodeCamp» в конец массива строк. Добавьте этот код перед console.log, чтобы увидеть изменения, внесённые в массив.

let rows = ["Naomi", "Quincy", "CamperChan"];
rows.push("freeCodeCamp");
console.log(rows);


Шаг 27.

 Ещё один важный метод для этого проекта — метод .pop(). Он удаляет последний элемент из массива и возвращает этот элемент. Когда метод возвращает значение, можно считать, что он возвращает его вам, делая его доступным для использования в других частях кода. Создайте новую переменную с именем popped и присвойте ей результат rows.pop(). Затем выведите log popped на консоль.

let rows = ["Naomi", "Quincy", "CamperChan"];
rows.push("freeCodeCamp");
let popped = rows.pop();
console.log(rows);
console.log(popped);


Шаг 28.

Вы должны были увидеть сообщение "freeCodeCamp" в консоли. Это связано с тем, что .pop() возвращает значение, удалённое из массива, а вы ранее добавили "freeCodeCamp" в конец массива. Но что возвращает .push()? Присвойте существующий метод rows.push() новой переданной переменной и запишите его в журнал.

rows.push("freeCodeCamp");
let pushed = rows.push();
console.log(pushed);


Шаг 29.

Вы ожидали увидеть 4 в консоли? .push() возвращает новую длину массива после прибавления переданного вами значения. Важно понимать, какие значения возвращает метод.


Шаг 32.

Теперь вы готовы приступить к построению генератора пирамиды. Ваша символьная переменная послужит строительным блоком для пирамиды. "Hello" может не подойти для этой цели. Измените значение символа на символ решётки "#".

const character = "#";
const count = 8;
const rows = [];


Шаг 33.

Чтобы построить пирамиду, вам потребуется создать несколько строк. Если вам нужно многократно выполнять задачу до тех пор, пока не выполнится условие, вы используете цикл. Существует множество способов написать цикл. Начнем с простого цикла for. Циклы for используют следующий синтаксис:
Пример кода

for (итератор; условие; итерация) { логика; }

На следующих этапах вы подробно изучите каждый компонент цикла. Для начала создайте цикл for, включающий термины «итератор», «условие» и «итерация» для трех компонентов. Оставьте тело цикла, заключенное в фигурные скобки {}, пустым.

const character = "#";
const count = 8;
const rows = [];

for ("iterator"; "condition"; "iteration") {

}


Шаг 34.

Теперь вашему циклу нужен правильный итератор. Итератор — это переменная, которую вы можете объявить специально в цикле for, чтобы управлять итерацией или выполнением вашей логики. Принято использовать i в качестве переменной-итератора в цикле. Цикл for позволяет объявить это в скобках (). Например, вот цикл for, который объявляет переменную index и присваивает ей значение 100.
Пример кода
for (let index = 100; "second"; "third") {

 }

  Замените строку "iterator" объявлением let для переменной i. Присвойте ей начальное значение 0. Это присвоит переменной i значение 0 при первом выполнении цикла.

const character = "#";
const count = 8;
const rows = [];

for (let i = 0; "condition"; "iteration") {

}


Шаг 35.

 Условие цикла for определяет, сколько раз цикл должен повториться. Когда условие становится ложным, цикл останавливается. В JavaScript логическое значение может быть либо true, либо false. Это не строки — позже вы узнаете больше об этом различии. На данный момент мы будем использовать оператор «меньше» (<). Он позволяет проверить, меньше ли значение слева значения справа. Например, count < 3 будет true, если count равно 2, и false, если count равно 4. Замените строку «condition» на условие для проверки того, меньше ли i значения count.

const character = "#";
const count = 8;
const rows = [];

for (let i = 0; i < count; "iteration") {

}

Шаг 36.

Ваш оператор итерации будет сообщать циклу, что делать с итератором после каждого выполнения. При переприсваивании переменной вы можете использовать её для ссылки на предыдущее значение до переприсваивания. Это позволяет, например, прибавлять три к существующему числу. Например, выражение bees = bees + 3 увеличит значение bees на три. Используйте этот синтаксис, чтобы заменить строку «iteration» на оператор переприсваивания, который увеличивает i на единицу.

const character = "#";
const count = 8;
const rows = [];

for (let i = 0; i < count; i = i + 1) {

}


Шаг 37.

Теперь ваш цикл должен выполниться восемь раз. Внутри тела цикла выведите значение итератора i и посмотрите, что произойдёт.

const character = "#";
const count = 8;
const rows = [];

for (let i = 0; i < count; i = i + 1) {
console.log(i);
}


Шаг 38.

Вы должны увидеть в консоли числа от нуля до семи, по одному в каждой строке. Это послужит основой для построения вашей пирамиды. Замените оператор log оператором для помещения i в массив строк.

const character = "#";
const count = 8;
const rows = [];

for (let i = 0; i < count; i = i + 1) {
  rows.push(i);
}


Шаг 39.

К сожалению, теперь вы не видите, что делает ваш цикл. Используйте let для объявления переменной-результата и присвойте ей пустую строку. Пустая строка обозначается кавычками без символа между ними, например, "".

let result = "";


Шаг 41.

Для работы со строкой результата вы будете использовать другой тип цикла. А именно, цикл for...of, который перебирает каждый элемент итерируемого объекта и временно присваивает его переменной. Синтаксис цикла for...of выглядит следующим образом:
Пример кода

 for (const value of iterable) {

  }

  Обратите внимание, что можно использовать const, поскольку переменная существует только в течение одной итерации, а не в течение всего цикла. Создайте цикл for...of для итерации по массиву строк, присваивая каждое значение переменной строки.

  for (const row of rows) {

}


Шаг 42:

 Помните, что в предыдущем цикле вы использовали оператор сложения + для увеличения значения i на 1. Подобное действие можно выполнить и со строковым значением, добавив новую строку к существующей. Например, hello = hello + "World"; добавит строку "World" к существующей строке, хранящейся в переменной hello. Это называется конкатенацией. В цикле for...of используйте оператор сложения для конкатенации значения строки с результатом.

const character = "#";
const count = 8;
const rows = [];

for (let i = 0; i < count; i = i + 1) {
  rows.push(i);
}

let result = ""

for (const row of rows) {
  result = result + row;
}
вывод:  01234567


Шаг 43.

 Теперь все ваши числа находятся на одной строке. Это не сработает для построения пирамиды. Вам потребуется добавлять новую строку к каждой строке. Однако нажатие клавиши Enter для вставки переноса строки между кавычками в JavaScript приведёт к ошибке анализа. Вместо этого необходимо использовать специальную управляющую последовательность \n, которая интерпретируется как новая строка при записи строки в журнал. Например:
 Пример кода

 lineOne = lineOne + "\n" + lineTwo;

 Используйте второй оператор сложения для добавления новой строки после результата и значений строки.

const character = "#";
const count = 8;
const rows = [];

for (let i = 0; i < count; i = i + 1) {
  rows.push(i);
}

let result = ""

for (const row of rows) {
  result = result + row + "\n";
}


Шаг 45.

Теперь у вас есть ряд символов #, но форма пирамиды всё ещё отсутствует. К счастью, переменная i представляет собой
номер текущей строки в цикле, что позволяет использовать её для создания пирамидальной структуры. Для этого воспользуйтесь методом .repeat(), доступным для строк. Этот метод принимает число в качестве аргумента, определяющего количество повторений целевой строки. Например, с помощью .repeat() можно сгенерировать строку "Код! Код! Код!":
  Пример кода

const activity = "Code! ";
activity.repeat(3);

Примените метод .repeat() к вашему символу и укажите ему i в качестве номера.

for (let i = 0; i < count; i = i + 1) {
  rows.push(character);
}

#
#
#
#
#
#
#
#

for (let i = 0; i < count; i = i + 1) {
  rows.push(character.repeat(i));
}

#
##
###
####
#####
######
#######


Шаг 46.

 Вы приближаетесь к цели! В этот момент вы столкнулись с так называемой ошибкой «не на единицу» — частой проблемой в языках индексации с нулевой базой, таких как JavaScript. Первый индекс массива строк равен 0, поэтому вы начинаете цикл for с i = 0. Но повторение строки ноль раз не приводит к выводу каких-либо данных. Чтобы исправить это, добавьте 1 к значению i в вызове .repeat(). Не присваивайте значение i обратно, как вы это делали в условиях цикла.

 for (let i = 0; i < count; i = i + 1) {
  rows.push(character.repeat(i + 1))
}


Шаг 47.

Логика форматирования этой пирамиды, вероятно, будет сложной, а значит, сейчас самое время вынести этот код в функцию. Функция — это блок кода, который можно повторно использовать в вашем приложении. Функции объявляются с использованием следующего синтаксиса:
Пример кода

function name(parameter) {

}

 Ключевое слово function сообщает JavaScript, что переменная name будет функцией. parameter — это переменная, представляющая значение, которое передается в функцию при ее использовании. Функция может иметь любое количество параметров. Как и в цикле for, пространство между фигурными скобками — это тело функции. Объявите функцию padRow. Пока не создавайте переменные параметров. Тело функции должно быть пустым. Помните, что для именования необходимо использовать стиль «camelCase».

 function padRow() {

}


Шаг 48.

Чтобы использовать функцию, необходимо её вызвать. Вызов функции указывает приложению выполнить код из функции, где бы вы её ни вызвали. Синтаксис вызова функции — это имя функции, за которым следуют скобки. Например, этот код определяет и вызывает тестовую функцию.
Пример кода

function test() { } test();

Вызов функции padRow.

function padRow() {

}
padRow();


Шаг 49.

Вы вызываете функцию padRow, но не делаете с этим вызовом никаких действий. Все функции в JavaScript возвращают значение, то есть предоставляют определённый результат своего вызова для использования в других местах. Чтобы увидеть результат вызова функции padRow, объявите переменную вызова и присвойте ей существующий вызов padRow.

const call = padRow();


Шаг 50.

Теперь добавьте оператор журнала для вывода значения переменной вызова.

function padRow() {

}
const call = padRow();
console.log(call);



Шаг 51.

Ваша переменная call имеет неопределённое значение, хотя вы его определили! Это связано с тем, что функция padRow в настоящее время не возвращает значение. По умолчанию функции возвращают undefined в качестве своего значения. Чтобы вернуть что-то другое, необходимо использовать ключевое слово return. Вот пример функции, которая возвращает строку «Функции — это круто!»:
Пример кода

function demo() {
  return "Functions are cool!";
}

Используйте ключевое слово return, чтобы функция возвращала строку «Hello!».

function padRow() {
return "Hello!"
}


Шаг 52.

Если в вашем коде есть значение, явно прописанное в коде, например, строка «Hello!» в функции, оно считается жёстко заданным. Жёсткое кодирование значения внутри функции может сделать её не такой многоразовой, как хотелось бы. Вместо этого вы можете определить параметры для функции. Параметры — это специальные переменные, которым присваивается значение при вызове функции, и которые могут использоваться в вашей функции для динамического изменения результата её кода. Чтобы добавить параметр в функцию, необходимо указать имя переменной в скобках. Например, эта демонстрационная функция имеет параметр name:
Пример кода

function demo(name) {

 }

 name звучит как полезный параметр, поэтому добавьте его в функцию padRow.

 function padRow(name) {
  return "Hello!";
}


Шаг 53.

Функция не обязательно должна возвращать жёстко заданное значение. Она может возвращать значение, сохранённое в переменной. Параметры — это специальные переменные функции, поэтому их также можно возвращать. Измените функцию padRow так, чтобы она возвращала параметр name напрямую.

function padRow(name) {
  return name;
}


Шаг 54.

Если вы снова откроете консоль, вы увидите, что функция padRow возвращает undefined, несмотря на то, что вы определили возвращаемое значение! Это связано с тем, что параметрам необходимо присваивать значение при вызове функции. Когда вы передаёте значение в вызов функции, это значение называется аргументом. Вот пример вызова демонстрационной функции и передачи "Naomi" в качестве аргумента для параметра name.
Пример кода

function demo(name) {
 return name;
 }
 demo("Naomi");

 Передайте своё имя в качестве аргумента для параметра name в вызове padRow. Помните, что ваше имя — это строка, поэтому вам необходимо использовать кавычки.

 const call = padRow("A");


 Шаг 55.

 Прежде чем двигаться дальше, уделите немного времени изучению работы функций. Объявите функцию с именем addTwoNumbers. Эта функция должна принимать два аргумента и возвращать их сумму. Ваша функция не должна использовать жёстко заданные значения. Пример жёстко заданной функции:
 Пример кода

 function sayName(firstName, lastName) {
  return "John Doe";
  }
  sayName("Camper", "Cat");

  Эта функция вернёт "John Doe" независимо от аргументов, переданных параметрам firstName и lastName, поэтому "John Doe" считается жёстко заданным значением. Объявите переменную суммы и присвойте ей значение вызова функции addTwoNumbers с аргументами 5 и 10. Выведите значение переменной суммы в консоль.

function addTwoNumbers(num1, num2) {
  return num1 + num2;
}

const sum = addTwoNumbers(5, 10);
console.log(sum)



Шаг 57.

Переменные в JavaScript доступны в определённой области видимости. Другими словами, место объявления переменной определяет, где в коде она может быть использована. Первая область видимости — глобальная. Переменные, объявленные вне любого «блока», например, функции или цикла for, находятся в глобальной области видимости. Переменные character, count и rows находятся в глобальной области видимости. Когда переменная находится в глобальной области видимости, функция может получить к ней доступ в её определении. Вот пример функции, использующей глобальную переменную title:
Пример кода

const title = "Professor ";
function demo(name) {
 return title + name;
 }
 demo("Naomi")

 Этот пример вернёт значение "Professor Naomi". Обновите функцию padRow так, чтобы она возвращала значение, полученное путём конкатенации вашей character переменной с началом параметра name.

function padRow(name) {
  return character + name;
}


Шаг 64.

Чтобы знать, как форматировать строку, вашей функции padRow необходимо знать номер текущей строки и общее количество генерируемых строк. Лучший способ сделать это — создать для них параметры. Присвойте функции padRow параметры rowNumber и rowCount. Несколько параметров разделяются запятой:
Пример кода

function name(first, second) {

}
****

function padRow(rowNumber, rowCount) {

}


Шаг 65.

Помните, на предыдущем шаге вы узнали о возвращаемых значениях. Функция может возвращать значение, которое ваше приложение может использовать отдельно. В функции ключевое слово return используется для указания возвращаемого значения. Например, эта функция вернет значение, переданное первому параметру:

Пример кода

function name(parameter) {
  return parameter;
}

Используйте ключевое слово return для возврата значения character переменной, повторяющейся rowNumber раз.

function padRow(rowNumber, rowCount) {
  return character.repeat(rowNumber);
}


Шаг 66.

Вызов функции позволяет вам фактически использовать функцию. Возможно, вы не знали об этом, но такие методы, как .push(), которые вы использовали, являются вызовами функций. Функция вызывается путём ссылки на имя функции и добавления (). Вот как вызвать тестовую функцию:
Пример кода

test();

Замените символ .repeat(i + 1) в вызове .push() на вызов функции padRow. Пока не добавляйте к нему аргументы.

for (let i = 0; i < count; i = i + 1) {
  rows.push(padRow())
}



Шаг 67.

Ваша функция padRow имеет два параметра, которые вы определили. Значения этим параметрам передаются при вызове функции. Значения, которые вы передаете при вызове функции, называются аргументами, и вы передаете аргументы при вызове функции. Вот вызов функции с "Hello" в качестве аргумента:
Пример кода

test("Hello");

Передайте i + 1 и подсчитайте количество аргументов для вызова padRow. Как и параметры, аргументы разделяются запятой.

for (let i = 0; i < count; i = i + 1) {
  rows.push(padRow(i + 1, count))
}


Шаг 68.

Теперь вы должны увидеть в консоли тот же набор символов. Функция padRow выполняет то же самое, что и раньше, но теперь она находится в отдельном разделе, пригодном для повторного использования. Используйте оператор сложения, чтобы добавить один пробел " " в начало и конец повторяющейся строки символов. Помните, что оператор + можно использовать для объединения строк, например:
Пример кода

 " " + "string"

***

function padRow(rowNumber, rowCount) {
  return " " + character.repeat(rowNumber) + " ";
}


Шаг 69.

Теперь пора заняться математикой. Рассмотрим трёхрядную пирамиду. Если мы хотим, чтобы она была центрирована, это будет выглядеть примерно так:
Пример кода

··#·· ·###· #####

Для удобства чтения пустые пробелы заменены точками-интерпунктами. Если экстраполировать этот шаблон, можно увидеть, что пробелы в начале и конце строки следуют определённому шаблону. Обновите строки с пустыми пробелами так, чтобы они повторялись rowCount - rowNumber раз. Откройте консоль, чтобы увидеть результат.

function padRow(rowNumber, rowCount) {
  return " ".repeat(rowCount - rowNumber) + character.repeat(rowNumber) + " ".repeat(rowCount - rowNumber);
}


Шаг 70.

В качестве аргумента можно передавать полные выражения. Функция получит результат вычисления этого выражения. Например, два вызова функций ниже дадут одинаковый результат. (Обратите внимание, что применяется правило PEMDAS о порядке выполнения операций — скобки, возведение в степень, умножение, деление, сложение, вычитание):
Пример кода

test(2 * 3 + 1);
test(7);

Просмотрим шаблон ещё раз:
Пример кода

··#·· ·###· #####

Обновите значение символа, чтобы оно повторялось 2 * rowNumber - 1 раз. Откройте консоль ещё раз, чтобы увидеть обновлённый результат.

function padRow(rowNumber, rowCount) {
  return " ".repeat(rowCount - rowNumber) + character.repeat(2 * rowNumber - 1) + " ".repeat(rowCount - rowNumber);
}

test = test + 1;
test += 1;

let test = 7;
test++;


Шаг 73.

Вместо того, чтобы передавать i + 1 в вызов padRow, вы можете начать цикл с 1. Это позволит создать цикл с индексом 1. Обновите итератор, чтобы он начинался с 1 вместо 0.

for (let i = 1; i < count; i++) {
  rows.push(padRow(i + 1, count));
}


Шаг 74.

Пирамида теперь выглядит немного странно. Поскольку вы начинаете цикл с 1, а не с 0, вам не нужно прибавлять единицу к i при передаче его в padRow. Измените первый аргумент вызова padRow на i.

for (let i = 1; i < count; i++) {
  rows.push(padRow(i, count));
}


Шаг 75.

К сожалению, теперь основание пирамиды исчезло. Это связано с тем, что вы создали ещё одну ошибку, связанную с отклонением на единицу. Ваш исходный цикл выполнялся для значений i от 0 до 7, поскольку count равно 8, а ваше условие требует, чтобы i было меньше count. Теперь ваш цикл выполняется для значений i от 1 до 7. Ваш цикл необходимо обновить, чтобы он выполнялся и при i, равном 8. Судя по вашей логике, это означает, что ваш цикл должен выполняться, когда i меньше или равно count. Для этого можно использовать оператор «меньше или равно» <=. Измените условие цикла так, чтобы оно выполнялось, пока i меньше или равно count.

for (let i = 1; i <= count; i++) {
  rows.push(padRow(i, count));
}


Шаг 78.

Ваша пирамида снова исчезла. Ничего страшного, этого следовало ожидать. Прежде чем создавать новый цикл, вам необходимо изучить операторы if. Оператор if позволяет выполнить блок кода только при выполнении условия. Он использует следующий синтаксис:
Пример кода

if (условие) { логика }

Создайте оператор if с логическим значением true в качестве условия. В теле цикла выведите строку "Condition is true".

if (true) {
  console.log("Condition is true");
}


Шаг 79.

Вы увидите строку, выведенную в консоль, поскольку true действительно является true. Измените условие оператора if на логическое false.

if (false) {
  console.log("Condition is true");
}


Шаг 80.

Теперь строка больше не выводится, потому что false не является true. Но что насчёт других значений? Попробуйте изменить условие на строку «false».

if ("false") {
  console.log("Condition is true");
}



Шаг 81.

Текст снова появился! Это связано с тем, что «false» — это строка, которая при вычислении как логического значения становится «истиной». Это означает, что «false» — истинное значение. Истинное значение — это значение, которое считается истинным при вычислении как логического значения. Большинство значений, встречающихся в JavaScript, будут истинными. Ложное значение — это противоположность: значение считается ложным при вычислении как логического значения. В JavaScript определён список ложных значений. Некоторые из них включают «false», 0, «», null, undefined и NaN. Попробуйте заменить условие if на пустую строку «», которая является ложным значением.

if ("") {
  console.log("Condition is true");
}


Шаг 82.

Текст снова исчез! Пустые строки возвращают значение «ложь», что делает их ложными значениями. Вы узнаете больше об истинных и ложных значениях в будущих проектах. Помимо операторов if, в JavaScript также есть операторы else if. Операторы else if позволяют проверять несколько условий в одном блоке кода. Вот синтаксис оператора else if:
Пример кода

if (condition1) {
  // code to run if condition1 is true
} else if (condition2) {
  // code to run if condition2 is true
} else if (condition3) {
  // code to run if condition3 is true
}

   Если первое условие ложно, JavaScript проверит следующее условие в цепочке. Если второе условие ложно, JavaScript проверит третье условие и так далее. Под оператором if добавьте оператор else if, который проверяет, меньше ли "5 is less than 10". Затем внутри тела оператора else if выведите на консоль строку «5 меньше 10». Проверьте консоль, чтобы увидеть результаты.

   if ("") {
  console.log("Condition is true");
} else if (5 < 10) {
  console.log("5 is less than 10");
}



Шаг 83.

Иногда требуется выполнить другой код, когда все условия if...else if ложны. Это можно сделать, добавив блок else. Блок else будет выполняться только в том случае, если условия в блоках if и else if не выполнены. В данном случае блок else добавляется к блоку else if.
Пример кода

if (condition) {
 // этот код выполнится, если условие истинно
 } else if (condition2) {
  // этот код выполнится, если первое условие ложно
 } else {
   // этот код выполнится // если первое и второе условия ложны
 }

Добавьте блок else к блоку else if. Внутри блока else выведите на консоль строку "This is the else block". Чтобы увидеть результаты в консоли, можно вручную заменить символ < в операторе else if на >. Это сделает условие ложным, и блок else выполнится

if ("") {
  console.log("Condition is true");
} else if (5 > 10) {
  console.log("5 is less than 10");
} else {
  console.log("This is the else block");
}


Шаг 85.

Цикл while будет выполняться снова и снова, пока заданное условие не перестанет быть истинным. Он имеет следующий синтаксис:
Пример кода

while (условие) {
 логика; }

 Используйте этот синтаксис для объявления цикла while с условием continueLoop. Тело цикла должно быть пустым.

let continueLoop = false;
let done = 0;

while (continueLoop) {

}



Шаг 86.

Если сейчас изменить continueLoop на true, ваш цикл while будет выполняться вечно. Это называется бесконечным циклом, и вам следует быть осторожным, чтобы избежать этого. Бесконечный цикл может заблокировать вашу систему, и для выхода потребуется полная перезагрузка. Чтобы избежать этого, начните с использования оператора инкремента для увеличения значения переменной done внутри цикла.

while (continueLoop) {
 done++;
} if (done == count) {

}


Шаг 87.

Оператор равенства == используется для проверки равенства двух значений. Для сравнения двух значений используется оператор типа value == 8. Ниже done++ внутри цикла добавьте оператор if. Оператор должен проверять равенство done значению count с помощью оператора равенства.

while (continueLoop) {
  done++;
  if (done == count) {

  }
}




Шаг 88.

Оператор равенства может приводить к странному поведению в JavaScript. Например, «0» == 0 является истинным, даже если одно из значений — строка, а другое — число. Оператор строгого равенства === используется для проверки равенства двух значений и их типов. Как правило, именно этот оператор равенства следует использовать всегда. При использовании оператора строгого равенства «0» === 0 становится ложным, поскольку, хотя они могут иметь одинаковое значение — ноль, — они не относятся к одному типу. Обновите условие done == count, чтобы использовать оператор строгого равенства.

if (done === count) {

  }



Шаг 89.

Когда done достигнет значения count, мы хотим, чтобы выполнение цикла остановилось. В теле оператора if присвойте переменной continueLoop логическое значение false.

if (done === count) {
    continueLoop = false;
  }



Шаг 90.

Чтобы снова сгенерировать пирамиду, добавьте результат вызова padRow с done и count в качестве аргументов в массив rows, аналогично тому, как вы это делали в первом цикле.

rows.push(padRow(done, count));



Шаг 91.

Оператор строгого неравенства !== позволяет проверить, равны ли два значения или имеют ли они разный тип. Синтаксис аналогичен оператору равенства: value !== 4. В настоящее время цикл while выполняется только при истинности continueLoop. Обновите условие цикла while, чтобы проверить, не равно ли done значению count.

while (continueLoop) {
  done++;
  rows.push(padRow(done, count));
  if (done === count) {
    continueLoop = false;
  }
}

***

while (done !== count) {
  done++;
  rows.push(padRow(done, count));
  if (done === count) {
    continueLoop = false;
  }
}


Шаг 94.

Ваш генератор пирамид всё ещё работает. Однако существует вероятность повторного попадания в бесконечный цикл. Поскольку вы проверяете только, что done не равно count, если done будет больше count, цикл будет продолжаться вечно. Обновите условие цикла, чтобы проверить, что done меньше или равно count.

let done = 0;

while (done !== count) {
  done++;
  rows.push(padRow(done, count));
}

***

let done = 0;

while (done <= count) {
  done++;
  rows.push(padRow(done, count));
}



Шаг 95.

Использование done для отслеживания количества сгенерированных строк является функциональным, но вы можете немного упростить логику. У массивов есть специальное свойство length, которое позволяет увидеть количество значений или элементов в массиве. Для доступа к этому свойству используется синтаксис myArray.length. Обратите внимание, что rows.length в вызове padRow приведёт к ошибке «завышено на единицу», поскольку done увеличивается до вызова. Обновите условие, чтобы проверить, меньше ли rows.length значения count.

let done = 0;

while (done <= count) {
  done++;
  rows.push(padRow(done, count));
}

***

while (rows.length < count) {
  done++;
  rows.push(padRow(done, count));
}


Шаг 96.

Замените ссылку done в вызове padRow на rows.length + 1.

while (rows.length < count) {
  done++;
  rows.push(padRow(done, count));
}

***

while (rows.length < count) {
  done++;
  rows.push(padRow(rows.length + 1, count));
}



Шаг 99.

Что, если вы перевернёте свою пирамиду? Пора попробовать! Начните с создания нового цикла for. Объявите итератор i и присвойте ему значение count, а затем используйте логическое значение false для условий и итераций.


 for (let i = count; false; false) {

}


Шаг 100.

Поскольку вы собираетесь выполнять цикл в обратном направлении, ваш цикл должен выполняться, пока i больше 0. Для этого можно использовать оператор «больше» (>). Установите условие цикла на выполнение, когда i больше 0.

for (let i = count; false; false) {

}

***

for (let i = count; i > 0; false) {

}


Шаг 101.

Ваш оператор итерации также будет другим. Вместо прибавления 1 к i в каждом цикле вам нужно вычитать 1. Как и ранее с i = i + 1, обновите ваш оператор итерации, чтобы присвоить i значение, равное вычитанию 1 из самого себя.

for (let i = count; i > 0; false) {

}

***

for (let i = count; i > 0; i = i-1) {

}


Шаг 102.

Снова добавьте результат вызова padRow с переменными i и count в массив rows. Откройте консоль, чтобы увидеть перевернутую пирамиду.

for (let i = count; i > 0; i = i - 1) {

}

***

for (let i = count; i > 0; i = i - 1) {
  rows.push(padRow(i, count));
}



Шаг 103.

Как и для сложения, для вычитания можно использовать различные операторы. Оператор присваивания вычитания (-=) вычитает заданное значение из текущего значения переменной, а затем присваивает результат обратно переменной. Замените оператор итерации на правильный оператор, используя оператор присваивания вычитания.


for (let i = count; i > 0; i = i - 1) {
  rows.push(padRow(i, count));
}

***

for (let i = count; i > 0; i -= 1) {
  rows.push(padRow(i, count));
}


Шаг 104.

Поскольку вы вычитаете из i только единицу, можно использовать оператор декремента --. Замените присваивание вычитания оператором декремента.

for (let i = count; i > 0; i--) {
  rows.push(padRow(i, count));
}



Шаг 107.

Метод .unshift() массива позволяет добавить значение в начало массива, в отличие от .push(), который добавляет значение в конец массива. .unshift() возвращает новую длину массива, для которого он был вызван.
Пример кода

const countDown = [2, 1, 0];
const newLength = countDown.unshift(3);
console.log(countDown); // [3, 2, 1, 0]
console.log(newLength); // 4

Используйте const для объявления unshifted переменной и присвойте ей результат вызова .unshift() для массива numbers. Передайте 5 в качестве аргумента. Затем выведите несдвинутую переменную на экран.

const numbers = [1, 2, 3];

console.log(numbers);

***

const numbers = [1, 2, 3];
const unshifted = numbers.unshift(5);
console.log(numbers);
console.log(unshifted);



Шаг 108.

У массивов также есть метод .shift(). Он удаляет первый элемент массива, в отличие от .pop(), который удаляет последний элемент. Вот пример метода .shift():
Пример кода

const numbers = [1, 2, 3];
numbers.shift();

Массив numbers будет иметь размер [2, 3]. Прямо под массивом numbers объявите переменную shifted и присвойте ей результат вызова метода .shift() для массива numbers. В следующей строке выведите значение shifted на консоль.

const numbers = [1, 2, 3];


const unshifted = numbers.unshift(5);
console.log(unshifted);
console.log(numbers);

***

const numbers = [1, 2, 3];
const shifted = numbers.shift();
console.log(shifted);
const unshifted = numbers.unshift(5);
console.log(unshifted);
console.log(numbers);


Шаг 111.

Ваша пирамида больше не перевернута. Это связано с добавлением новых строк в конец массива. Обновите тело цикла, чтобы добавить новые строки в начало массива.

for (let i = 1; i <= count; i++) {
  rows.push(padRow(i, count));
}

***

for (let i = 1; i <= count; i++) {
  rows.unshift(padRow(i, count));
}



Шаг 112.

Что, если бы у вас был способ переключаться между перевёрнутой и стандартной пирамидами? Начнем с объявления инвертированной переменной и присвоения ей значения true. Вы не меняете эту переменную в коде, но вам потребуется использовать let, чтобы наши тесты могли изменять её позже.

let inverted = true;



Шаг 113.

Используйте оператор if для проверки истинности inverted. Помните, что здесь не нужно использовать оператор равенства.

for (let i = 1; i <= count; i++) {

  rows.unshift(padRow(i, count));
}

***

for (let i = 1; i <= count; i++) {
  if (inverted) {
    true
  }
  rows.unshift(padRow(i, count));
}



Шаг 114.

Теперь переместите вызов .unshift() в блок if.

for (let i = 1; i <= count; i++) {
  if (inverted) {

  }
  rows.unshift(padRow(i, count));
}

***

for (let i = 1; i <= count; i++) {
  if (inverted) {
    rows.unshift(padRow(i, count));
  }

}



Шаг 115.

Если ваша пирамида не перевернута, вам понадобится блок else, который строит пирамиду в обычном порядке. На предыдущих шагах вы научились работать с оператором else следующим образом:
Пример кода

if (условие) {
 // если условие истинно, выполнить этот код
 } else {
  // если условие ложно, выполнить этот код
  }

  Добавьте блок else к блоку if.

for (let i = 1; i <= count; i++) {
  if (inverted) {
    rows.unshift(padRow(i, count));
  }

}

***

for (let i = 1; i <= count; i++) {
  if (inverted) {
    rows.unshift(padRow(i, count));
  } else {

  }
}



Шаг 116.

Если inverted равно false, нужно построить стандартную пирамиду. Для этого используйте .push(), как и в предыдущих шагах.

for (let i = 1; i <= count; i++) {
  if (inverted) {
    rows.unshift(padRow(i, count));
  } else {

  }
}

***

for (let i = 1; i <= count; i++) {
  if (inverted) {
    rows.unshift(padRow(i, count));
  } else {
    rows.push(padRow(i, count));
  }
}

 */