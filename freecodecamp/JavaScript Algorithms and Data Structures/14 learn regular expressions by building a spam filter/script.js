const messageInput = document.getElementById("message-input");
const result = document.getElementById("result");
const checkMessageButton = document.getElementById("check-message-btn");

const helpRegex = /please help|assist me/i;
const dollarRegex = /[0-9]+\s*(?:hundred|thousand|million|billion)?\s+dollars/i;
const freeRegex = /fr[e3][e3] mon[e3]y/i;

const denyList = [helpRegex, dollarRegex, freeRegex];

const isSpam = (msg) => denyList.some((regex) => regex.test(msg));

checkMessageButton.addEventListener("click", () => {
    if (messageInput.value === "") {
        alert("Please enter a message.");
        return;
    }
    result.textContent = isSpam(messageInput.value) ? "Oh no! This looks like a spam message." : "This message does not seem to contain any spam.";
    messageInput.value = "";
});


























/*
Шаг 1

Для начала проекта используйте метод `.getElementById()`, чтобы получить элементы `#message-input`, `#result` и `#check-message-btn` из HTML-документа и присвойте их переменным `messageInput`, `result` и `checkMessageButton` соответственно.





Шаг 2

Прикрепите обработчик событий к вашей кнопке checkMessageButton, отслеживающий событие клика. Добавьте к нему пустую функцию обратного вызова.





Шаг 3

Если поле messageInput пустое, выведите пользователю сообщение "Пожалуйста, введите сообщение." Затем завершите выполнение функции.


checkMessageButton.addEventListener("click", () => {
  if (messageInput.value === "") {
    alert("Please enter a message.");
    return;
  }
});





Шаг 4

Создайте функцию isSpam, используя ключевое слово const и стрелочный синтаксис. Функция должна принимать один параметр msg и пока что неявно возвращать false.


const isSpam = (msg) => false;





Шаг 5

В обработчике событий необходимо обновить текст элемента результата. Для этого можно использовать тернарный оператор. Вот пример присвоения результата тернарного оператора текстовому содержимому элемента:
Пример кода

el.textContent = condition ? "Use this text if the condition is true" : "Use this text if the condition is false";

После оператора if используйте тернарный оператор для проверки истинности вызова функции isSpam() с аргументом messageInput.value. Если истинно, установите свойство textContent элемента результата в значение "О нет! Это похоже на спам-сообщение." В противном случае установите его в значение "Это сообщение, похоже, не содержит спама." Затем установите свойство value элемента messageInput в пустую строку.


checkMessageButton.addEventListener("click", () => {
  if (messageInput.value === "") {
    alert("Please enter a message.");
    return;
  }
  result.textContent = isSpam(messageInput.value) ? "Oh no! This looks like a spam message." : "This message does not seem to contain any spam.";
  messageInput.value = "";
});





Шаг 6

Ваше первое регулярное выражение будет использоваться для перехвата запросов на помощь. Объявите переменную helpRegex и присвойте ей регулярное выражение, соответствующее строке "пожалуйста, помогите". В качестве напоминания, вот регулярное выражение для сопоставления строки "hello world": Пример кода const regex = /hello world/;


const helpRegex = /please help/;





Шаг 7

Регулярные выражения могут принимать флаги для изменения своего поведения. Например, флаг i можно использовать, чтобы выражение игнорировало регистр, в результате чего оно будет соответствовать словам hello, HELLO и Hello для выражения /hello/. Флаги добавляются после завершающей косой черты. Добавьте флаг i в ваше helpRegex.


const helpRegex = /please help/i;





Шаг 8

Строки имеют метод `.match()`, который принимает в качестве аргумента регулярное выражение и определяет, соответствует ли строка этому выражению. Обновите функцию `isSpam()` так, чтобы она неявно возвращала результат вызова метода `.match()` для `msg`, передавая в качестве аргумента `helpRegex`. Затем попробуйте ввести несколько сообщений на вашей странице и посмотрите результат.


const isSpam = (msg) => msg.match(helpRegex);





Шаг 9

Вместо использования метода `.match()`, вы можете использовать метод `.test()` регулярного выражения, чтобы проверить, соответствует ли строка шаблону. В отличие от `.match()`, `.test()` возвращает логическое значение, указывающее, соответствует ли строка шаблону или нет. Обновите функцию `isSpam()`, чтобы она использовала метод `.test()` функции `helpRegex` для проверки соответствия шаблону `msg`. Затем попробуйте ввести несколько сообщений на вашей странице и посмотрите результат.


const isSpam = (msg) => helpRegex.test(msg);





Шаг 10

Альтернативная последовательность | может использоваться для сопоставления либо текста слева, либо текста справа от |. Например, регулярное выражение /yes|no/ будет соответствовать либо yes, либо no. Обновите ваше helpRegex, чтобы оно соответствовало либо please help, либо assist me.


const helpRegex = /please help|assist me/i;





Шаг 11

Прежде чем начать создавать дополнительные регулярные выражения, необходимо обновить приложение, чтобы оно проверяло более одного регулярного выражения. Начните с объявления переменной denyList. Присвойте ей массив, содержащий ваше helpRegex.


const denyList = [helpRegex];





Шаг 12

У массивов есть метод `.some()`. Как и метод `.filter()`, `.some()` принимает функцию обратного вызова, которая должна принимать элемент массива в качестве аргумента. Метод `.some()` вернет `true`, если функция обратного вызова возвращает `true` хотя бы для одного элемента массива. Вот пример вызова метода `.some()` для проверки, является ли какой-либо элемент массива заглавной буквой.
Пример кода:

const arr = ["A", "b", "C"];
arr.some(letter => letter === letter.toUpperCase());

Используйте метод `.some()` для проверки того, возвращает ли проверка вашего msg на любом из ваших регулярных выражений `denyList` `true`. Для большей ясности используйте `regex` в качестве параметра для функции обратного вызова.


const isSpam = (msg) => denyList.some((regex) => regex.test(msg));





Шаг 13

Следующее регулярное выражение, с которым вы будете работать, — это выражение, которое соответствует упоминаниям сумм в долларах. Начните с объявления переменной dollarRegex и присвойте ей регистронезависимое регулярное выражение, которое соответствует тексту «доллары».





Шаг 14

Добавьте ваш dollarRegex в массив denyList, чтобы вы могли протестировать регулярное выражение. Затем попробуйте ввести сообщение в вашем приложении.


const denyList = [helpRegex, dollarRegex];





Шаг 15

Вам нужно найти число перед текстом dollars. Хотя вы могли бы написать 0|1|2 и так далее, регулярные выражения имеют функцию, которая упрощает это. Класс символов определяется квадратными скобками и соответствует любому символу внутри скобок. Например, [aeiou] соответствует любому символу из списка aeiou. Вы также можете определить диапазон символов для сопоставления, используя дефис. Например, [a-z] соответствует любому символу от a до z. Добавьте класс символов для сопоставления цифр от 0 до 9 в ваше регулярное выражение dollarRegex — помните, что цифра должна стоять перед словом dollars, и между цифрой и словом должен быть пробел.


const dollarRegex = /[0-9] dollars/i;





Шаг 16

Сумма в долларах может состоять из нескольких цифр. Для сопоставления можно использовать квантификатор +, который соответствует одному или нескольким последовательным вхождениям. Например, регулярное выражение /a+/ соответствует одному или нескольким последовательным символам «a». Обновите ваше регулярное выражение, чтобы оно соответствовало одной или нескольким последовательным цифрам.


const dollarRegex = /[0-9]+ dollars/i;





Шаг 17

Между цифрами и текстом, обозначающим доллары, необходимо отображать разряды. Используйте символ | для обозначения сотен, тысяч, миллионов или миллиардов между цифрами и долларами.


const dollarRegex = /[0-9]+ hundred|thousand|million|billion dollars/i;





Шаг 18

Группа захвата — это способ определить часть выражения, которая должна быть захвачена и сохранена для последующего использования. Вы можете определить группу захвата, заключив часть выражения в скобки. Например, /h(i|ey) camper/ будет соответствовать либо hi camper, либо hey camper и захватит i или ey в группу. Превратите ваши значения разрядов в группу захвата.


const dollarRegex = /[0-9]+ (hundred|thousand|million|billion) dollars/i;





Шаг 19

Теперь, когда у вас есть группа захвата, вы можете пометить весь шаблон как необязательное совпадение. Квантификатор ? соответствует нулю или одному вхождению предыдущего символа или группы. Например, регулярное выражение /colou?r/ соответствует как color, так и colour, поскольку u является необязательным символом. Пометьте вашу группу захвата как необязательную.


const dollarRegex = /[0-9]+ (hundred|thousand|million|billion)? dollars/i;





Шаг 20

Хотя это выражение соответствует 100 долларам, оно не будет соответствовать 100 долларам или 10 долларам. Спам-сообщения могут и будут находить способы использовать уязвимости в вашей системе обнаружения. Пора улучшить ваши регулярные выражения. Замените первый пробел выражением \s*. Класс символов \s соответствует пробелам, таким как пробелы, табуляция и новые строки. Квантификатор * означает «соответствует предыдущему символу 0 или более раз». Замените второй пробел выражением \s+. Квантификатор + означает «соответствует предыдущему символу хотя бы один раз».


const dollarRegex = /[0-9]+\s*(hundred|thousand|million|billion)?\s+dollars/i;





Шаг 21

И ещё один момент, касающийся этого выражения. Вам на самом деле не нужно значение совпадения из вашей группы захвата, поэтому вы можете преобразовать её в группу без захвата. Это позволит вам группировать символы вместе, не сохраняя результат. Чтобы создать группу без захвата в регулярном выражении, вы можете добавить ?: после открывающей скобки группы. Например, (?:a|b) будет соответствовать либо a, либо b, но не будет захватывать результат. Обновите ваше регулярное выражение, чтобы использовать группу без захвата.





const dollarRegex = /[0-9]+\s*(?:hundred|thousand|million|billion)?\s+dollars/i;





Шаг 22

Ваше следующее регулярное выражение будет искать строки типа «free money». Начните с объявления переменной freeRegex и присвойте ей регулярное выражение, которое будет соответствовать строке «free money». Не забудьте сделать его нечувствительным к регистру.


const freeRegex = /free money/i;





Шаг 23

Добавьте новое регулярное выражение в массив denyList, чтобы вы могли его протестировать.





Шаг 24

В спам-сообщениях часто используются цифры вместо букв, чтобы обойти фильтры. Ваше регулярное выражение должно их отлавливать. Замените символы «e» в вашем регулярном выражении на классы символов, соответствующие «e» и «3».


const freeRegex = /fr[e3][e3] mon[e3]y/i;












 */